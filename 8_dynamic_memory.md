# Динамическая память
## Модель памяти
Программе необходимо где то хранить данные с которыми она работает, поэтому выделяют основные виды памяти:
 - Память сегмента кода(загружаються выполняемые инструкции нашей программы)
 - Память сегмента данных(загружаються статические и глобальные переменные), различают еще инициализированную и неинициализированную
 - Стек или другим словом автоматическая память(локальные переменные, аргументы функций, адресс возврата функции)
 - Динамическая память (Куча)

До этого мы работали только с сегментом данных (когда обьявляли глобальные переменные), и стек когда обьявляли локальные переменные вызывали функции. Проблема описанных видов памяти, кроме динамической, в том что их размер предустановлен. Необходимо уточнить что например возможность записать в сегмент кода, тоже не возможен, можно только использовать адресс функций (read-only). Для управления памятью во время выполнения программы, т.е. создание или удаление, используеться только стек и динамическая память.

Идея стека заключается в быстром выделении памяти, т.е. когда наша программа заходит в область видимости, например функции, то необходимо быстро выделить память под переменные. Это достигается одной CPU инструкцией, т.е. мы передвигаем указатель стека(специальный регистр), когда нам необходимо запросить память, и присваиваем переменной адресс на который указывает сейчас указатель стека(указатель стека перемещается снизу вверх). Данные в стеке расположены друг за другом(но необходимо помнить что компилятор делает так называемый memory reordering).

Проблема стека как было сказано выше в том что размер его предустановлен и мы не может контролировать время жизни переменных, т.к. стек это автоматическая мамять. И если нам необходимо больше размер памяти для хранения данных или увеличить время жизни переменных от вызова одной функции к вызову другой, то для этого используется динамическая память.

Но возникает вопрос почему не использовать динамическую памать по умолчанию, как сделано во многих языках программирования, и не будет проблем с переполнением стека и т.д., а ответ на этот вопрос раскрывается в том как память выделяеться в куче. Если программа запрашиввает необходимый обьям памяти, то этот запрос обращается к OS так называемый менеджер памяти, основные обьязательства следующие:

- Проверит есть ли доступная память
- Выделит запрашиваемую память
- И будет держать эту память для вашей программы, чтобы другие процессы не могли получить доступ к вашей памяти
- По вашему запросу освобождает память если она вам больше не нужна(если этого не зделать возникают memory leaks)
- Делает фрагментацию памяти

С выше всего перечисленного можно сделать вывод что выделение памяти это очень дорогая операция. Т.е. разница в производительности между стеком и динамической памятью это как система выделяет память. А вот работа с выделенной паматью ничем практически не отличается от работы с памятью в стеке, только в динамической паматьи образуется один дополнительный уровень косвености(указатель)
### Стек
 - Хранится в RAM как и динамическая память
 - Стек использует так называемую автоматическую работу с памятью (т.е. идея push - pop)
 - Намного производительней в выделении памяти чем динамическая память
 - Хранит локальные данные, адресс возврата функции, передаваемые аргументы функции
 - Т.к. количество памяти на стек ограничено, то возможно переполнения буфера
 - Стек используется если мы знаем точно размер памяти (но в рамках ограничения памяти на стеке)
### Куча
 - Хранится в RAM как и динамическая память
 - Переменные которые выделяются в динамической памяти, должны быть удалены в ручную, т.е. управление динамической памятью происходит вручную
 - Медляней в производительности в выделении памяти, чем стек
 - Память в куче используеться по требованию программы
 - Может возникнуть фрагментация памяти, когда много запросов на выделение и освобожнение
 - Можен возвращать ошибку выделения памяти, если запрос на выделение памяти очень большой чем обьем памяти
 - Возможны memory leaks(утечка памяти), если не освободить выделенную память
 - Куча в основном используеться если мы не знаем какой нам необходим обьем памяти, или время жизни переменой должно быть больше чем область например функции 

### Работа с динамической памятью

Работа с динамической паматью, будем ее дальше называть кучей, возможна только посредством указателя. Главной целью динамики это гибкое управление памятью, т.е. удалять необходимое количество памятьи, выделять, реалоцировать, т.е. реациловать памятью в рантайме в зависимости от контекста.
Также очень важной характеристикой динамики есть то что нам необходимо продлить время жизни объекта от вызова фукции к функции. Можно это реализовать посредством статических или глобальных переменных, но проблема их это область видимости, а указатели есть хороший механизм для более локального управления памятью.
Ну и ключевой особеностью это работа с большими динамически изменяемыми данными. Хочу заметить изменяемыми, если мы знаем размер необходимой нам памятьи, то лучше для этого использовать память сегмента данных и реализовать механизм взятия куска памятьи или удалить, т.е. освободить.
Запросы на выделения памяти происходит только посредством запроса к OS или менеджера памяти. Т.е. операционная система переключаеться между юзер спейс режима и кернел режимом, каждый раз когда вы запрашиваете запрос на выделение памяти. Память в куче выделяеться случайным образом, в отличии от стека где это есть последовательным. Ну а результатом при запросе на выделения память есть или адресс выделенного блока памяти, или система сообщит о неудаче несколькими способами, в зависимости от способа запроса.

В связи с такими сложностями выделения памяти, называют оверхед, т.е. накладные рассходы, или другим словом время вызова.

### Способы работы с динамической памятью в С++

В С++ используеться два подхода с работою с динамической памятью, один это старое наследие С, второй это использование встроеных операторов в с++.

На самом деле часто выделяют, то что подход с применением старых С функций выделяет память на куче, тогда как в применения опрераторов выделяет память в free store. Но как по мне они работают с той самой памятью, просто это сахар реализвации языка или компилятора , неважно. Важно то что С функции они вам дают так называемую сырую память, тогда как операторы они больше работаю с завершенным объектом. Многие реазицации операторов и правда под низом вызывают С функции, но иногда напрямую делают запросы в систему.

Ок давайте начнем со сложного выделение памяти с помощью С функций.
С функции бывают следующие `calloc, malloc, realloc` и одна функция для освобождения памяти `free`.

`calloc` и `malloc` отличаються только списком параметров. Для меня malloc есть более суровый.

`malloc` - выделяет указанную в парметрах количество байт памяти и возращает указатель на выделенную память.
`calloc` - выделяет более близко сказать массив данных(на самом деле все оно одинаковое), т.е. количество элементов умножено на размер элемента. Параметров два. Это более удобная запись.

Но есть у них еще одна разница, а именно это то что calloc инициализирует выделенную память нулем.

В случае неудачи в выделении памяти возращает указаетль на null. Т.е. после вызова этих функций стоит проверять на null

`realloc` это изменения или перераспределения памяти, т.е. динамически измения размера памяти. У него два паметра, первый это указатель на выделенную память, и второй это размер изменяемой памяти. Если уазать в качесве указателя на память null, то realloc будет себя вести так же как и malloc. При перераспределении памяти, выделяеться новый участок памяти, т.е. указатели которые могли ссылаться на этот участок памяти станут невалидными. При увеличении размера, новая память не заполняеться нулями. В случае успеха возращает адресс на новый участок памяти, в случае не успеха возращает null, хотя гарантируеться, что в случае не удачи старая память не измениться.

Освобождения памяти происходит вызовом функции `free`, не важно какой из выше описанных функций было выделенная память. Но есть два важных замечания, что вызов free с null указателем или повторный вызов функции уже освобожденной памяти есть неопредедленное поведение. Таже хорошим тоном есть писать после вызова free обнулять указатели, т.е. функция free этого не делает. Вторым очень важным моментом надо помнить что если память была выделена используя С++ оператор выделения памяти, то вызов функции free для ее освобождения будет неопределенным. Есть только один вопрос, откуда free знает сколько памяти надо удалить, все об этом знает менеджер памяти.

Ок, но в С++ немного проще  с этим. Во-первых в С++ рассматриваеться понитие выделения объекта нежели выделения сырой памяти. Ну и для этого служат операторы, которые розворачиваються в вызовы функции со своими алокаторами, где в С++ это просто вызов функции и возврат адресса. Т.е. С++ расматривает выделение памяти в free storage, т.е. как полноценный объект. На самом деле выделение памяти посредством языковых конструкций с++ очень сильно навернуто.
Начнем попорядку. `new` и `new[]` отличаються только тем что один используеться для выделения одного объекта, а второй для массива, ну и их пара это `delete` и `delete []`. Тут надо быть очень сильно внимательным и не перепутать, если вы создаете объект с помощью `new`, то и вызывать должны `delete`, если вы вызвите `delete []`, то согласно стандарту определение не определено. И наоброт то же с массивом. Как бы на этом можно и финишь сделать, но есть еще отличия от С функций это то что являеться результатом вызова этих операторов, есть исключение. Но есть и выриант вызова подобный С вызовам функций это так называемый `nothrow`, т.е полученный указатель надо проверять на null.
Но есть еще продвинутая фича, она полезна когда вы работаете с пулом памяти, т.е. память которая уже выделена вашей программе, например в сегменте данных, и вы на этом месте создаете указатель, т.е. например обнуляете значение которое хранилось в этой памяти, это называеться placement new.
Ок, теперь примеры.
```cpp

#include <stdio.h>
#include <stdlib.h>
#include <iostream>

int* allocate_memory() {
  int *memory = new int(100);
  return memory;
}

int main(void) {
  // в C++ необходимо явно преобразовывать возращаемый тип в функции malloc, т.к. функция возвращает нетипизированный указатель
  int *ptr = (int *)malloc(sizeof(int));
  printf("Value in ptr is %d \n", *ptr); // содержит муссор
  *ptr = 54;
  printf("Value in ptr is %d \n", *ptr); // print 54
  free(ptr);
  // free(ptr); // our program is crash double free
  ptr = nullptr;
  // free(ptr); // our program crash, ptr is null
  ptr = (int *)calloc(1, sizeof(int));
  printf("Value in ptr is %d \n", *ptr); // согласно документации calloc - the memory is set to zero.
  free(ptr);

  // C++ allocate memory style
  ptr = new int(20); // в отличии от системных функций в операторе new можно указывать инициализирующее значение 
  printf("Value in ptr is %d \n", *ptr); // print 20
  delete ptr; 

  const int count_memory = 5;
  // Allocate memory for array
  ptr = (int *)malloc(count_memory * sizeof(int)); // or calloc(count_memory, sizeof(int))
  free(ptr);

  ptr = new int [count_memory] {1,2,3,4}; // значения можно инициализировать также как массивы
  // delete ptr; // memory leaks
  delete[] ptr;
  
  auto ptr1 = allocate_memory();
  printf("Value in ptr1 is %d \n", *ptr1); // print 100
  delete ptr1;

  std::cout << "Placement new" << std::endl;
  
  int a = 90;
  std::cout << a << std::endl;

  int* ptr_alias_a = new (&a) int();

  std::cout << a << std::endl;
  std::cout << "Adress pointer alias a is " << ptr_alias_a << " and a is " << &a << std::endl;
  
  int* ptr_nothrow = new(std::nothrow)int(85);
  if (ptr_nothrow) {
    std::cout << *ptr_nothrow << std::endl;
    delete ptr_nothrow;
  }
  return 0;
}

```   