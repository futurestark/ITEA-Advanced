# Классы и объекты
## Базовые понятия ООП
Начнем с того что есть недостаком функционального и процедурного программирования.
К примеру у нас есть концепт очереди. То функциональьный подход разделяет данные и алгоритмы работы с этой очередью. Т.е. алгоритм и данные с которыми работает эта очередь есть две независимые сущности.
Например, добавление элемента в очередь
```
push_queue(queue, value);
``` 
как видим нам необходимо передавать саму очередь как параметр, то есть мы разделяем как и что.
Да можно например определить реализацию функционального подхода как отдельный модуль трансляции, определив например как статическую переменную внутри этого модуля, и вызывать просто интерфейсные функции работы с очередью. Но проблема что этот подход реализован для одного экземпляра. Ну будучи честным есть реализации ООП с помощью функционального подхода.

Программирования с помощью ООП подхода решает эту проблему, т.е. призван решить ее, он рассматривает и алгоритмы и данные как единую сущность.
Далеко отходя от понятий, хочу сказать что сам ООП, т.е. его философия, она не такая как ее реализовывает язык. К примеру когда зарождалась идея ООП, т.е. хотели предоставить идею клеточного организма которые общаються между собой сообщениями. Сам создатель ООП подхода, сказал что он не имеел ввиду ООП как С++.
ООП это подход, стиль программирования, модульность, и т.д. Подхода к описанию очень много. Мной импанирует смысл, это то что ООП призван представить нам наш реальний мир, т.е. выразить все как абстрация, и как объектность. Т.е. к примеру выразить абстракность автомиль форд, а вот его объект это реализация этой абстракции. Объект он представляет из себя данные(характеристики, которые описывают этот объект ) и поведение(т.е. то как управлять этим объектом). Например у нас есть объект у которого есть атрибуты модель, тип двигателя, тип авто, пробег. И есть методы упраления объектом, как внутрение, как внешние. Внешние мы даем наружу чтобы им или управляли, или модифицировали(т.е. меняли состояние), тогда как внутрение это то что происходит внутри объекта. Возращаясь к авто мы имеем внешний интерфейс, нажатия на педаль газа, при этом когда мы вызвали этот интерфейс(послали сообщение объекту), то нутри объекта начинает происходить много измениний, т.е. объект начал менять свое сотоянии, вызываеться внутриние методы работы с двигателем, раскрутка колесс, и т.д.
Хух, что то сказал)

Базовой единицей в ООП есть класс, это и есть инкапсуляция данных и методов(поведения) в единую коробоку. И который предоставляет интерфейс для работы с этой коробкой. И в связи что класс это хорошо инкапсулированаясущность, его удобно переиспользовать или изменять не влияя на внешний интерфейс. Возращаясь к функциональному программированию, скажем так что ООП объединяет данные и алгоритмы работы с этими данными в одну и ту же коробочку.
ООП подход это высокоуровневая абстракция которая призвана решать больше проблему, чем думать на тем как его решать(как представить эти данные к памяти и т.д.), для использующего ваш класс. Хороший пример это контейнер, который у себя инкапсулирует сложную логику выделения памяти, переноса памяти, для вас это прячится за кулисами этого класса, вы просто вызываете методы добавления в вектор, удаления, и вас не парит все сложности.

Но есть и большая избыточность использования этого ООП, люди начинают все в своей программе рассматривать как класс. Еще раз ООП призван решить более сложные технические объекты. Например нет смысла писать какойто парсер ввиде класса, когда его целью есть просто взять с файла данные представленные в одном формате, прдставить его в другом формате. Т.е. смысл этого то что даному парсеру не нужно состоянии. И это есть базовое понятие, т.е. в ООП это возможность сохранять состоянии (например, перемещения игрока по полю, его прокачанные скилы). А вот если не нужно состояние, то для этого прекрасно работает как раз и функциональное програмировние.
Пример же той же очереди. Есть у нас в системе будет только одна очередь, то зачем для этого городить подход с ООП если можно просто написать функциональный подход ввиде модульности, инкапсулируя просто одну только очередь.
Ок я думаю с каким то пониманием вы подошли уже к определения базовых концептов ООП.

Основной единицей есть **класс**. Это просто чертеж, абстракция, прототип, который просто описыват суть какие характеристики(данные) этого класса, и его поведение(при этом есть как внутренне и как ввнешенне).

**Объект** это уже реализация нашего чертижа описанного в классе. Т.е. это уже физическое представления класса. Т.е. этим мы создаем его внутрение атрибутты, т.е. внутренее состояние. Стоит сказать что мы можем созадавать много этих экземпляров, и каждый из них будет иметь свое независимое состояние, но повдение работы с ними одинаковыми.

**Абстракция** есть предоставление только нужной информации окружающей среде, при этом пряча детали имлементации. Т.е. предоставляються только внешние методы для работы с объеектом(типа сообщений). Польза от этого в том что вы можете менять внутренее состояния не меняя его внешний интерфейс.
**Инкапсуляция** это очень близко в абстрации, т.е. это комбинация в одном модуле данные и функции. И данные не доступны для других частей программы, а доступны только через функции. Это еще называют скрытие данных. Т.е. представление единого целого. Например чтобы поменять состояние объекта, не надо менять каждое поле, а происходит измение только через внешнюю функции. Это позволяет соблюдать целостность данных. Если мы до этого использовали структуры, то там поля объекта могли менять в разных частях программы где есть доступ к объекту. Тем самым объект не был в целостном состоянии.
**Наследование** этот термин мы рассотрим дальше в другом разделе
**Полиморфизм** этот термин мы рассотрим дальше в другом разделе 

## Работа с классом
Ок, после того как мы рассмотрели концепции ООП, хотя они реально поверхностные без тонкостей деталей, начнем писать наш первй класс.
Я хочу пошагово реализовать идею работы со стеком. Начиная от определения класса стек и заканчивая реализацией всех конструкторов.
Ок, начнем
Класс имеет что то схожее со структурой, т.е. структура хранит набор связанных данных. Но еще раз для меня структура, это некий логическое объединения данных, я его смысл рассмартриваю как в языке С. Т.е. это Plain Old Data, данные которые меняються не зависимо  друг от друга, в разных частях программы.
Но наченем с истории что классы как таковые реализовывались на С структурах. Это потом стало полнеценным классов.
Давайте пример
```
class Stack {

};
```

Как видим объявление похоже на структуру, разница ключевом слове толь `class`. Часто говорят что структура это тот же класс, только с небольшим отличием. Но нет, невсегда. Мы еще к этому вернемся.
Ну это называеться пустой класс, и размер его как структуры гарантирова будет не меньше 1 байта.
Но в таком классе смысла малло, давайте наполним его полями.
### Поля класса
Поля класса это то что и поля в структуре, т.е. они могут быть как встроеного типа, так и быть пользовательским. Но в классе в рамках ООП поля описывают состояние объекта этого класса. Т.е. синаксически это одно и тоже, но с другой семантикой. Ок, вернемся к нашему стеку. Что такое стек? это структура данных работающая по принципу LIFO, т.е. последний зашел и первым вышел. Стек это впринципе ограниченая каким то размером структура данных. Т.е. нам надо определить константу соответсвующая размеру стека, и важное это как мы будем представлять стек в памяти. Стек впринципе реализует идею массива, только с невозможностью получения доступа к элементу по индексу. Ок, т.е. у нас внутренне состоянии стека будет массива ограниченого костантой размера. Давайте добавим это.
```cpp
class Stack {
  int array[255];
};
```
ОК, у нас есть стек как пользовательский тип, который представляет из себя массив. Вопрос чем это отличаеться от структуры? В такой форме почти многим. Во первых если таким способом, если это вопрос структуры, то мы объявляем как С структуру со всеми вытекающими последствиями для С, без какой либо ООП магии. Таким объявлением, вместо `class` написать `struct`, мы гарантируем соместимость с С структурами. Мы будем к сравнениям возращатьс очень часто.
Но есть важное еще отличие это уровни доступа, т.е. если мы создадим объект этого типа и попытаемся получить доступ к полю, как мы делали это со структурой то получим ошибку компиляции.
```cpp
  Stack st;
  std::cout << st.array[0] << std::endl;
```
Мы получим интересную ошибку, типа мы пытаемся использовать что то `private`. Так что это такое то. Это называються уровни доступа. Их есть 3-и
1. **private** если объявлять что то в этом разделе то мы не сможем получить доступ к этим мемберам, объявленых в этом разделе .
2. **public** все что сдесь объявлено, являеться внешне доступным, т.е. все имеют доступ к мемберам объявленым в этом разделе.
3. **protected** это относить к наследованию, и мы его более подробно рассмотрим когда будет рассматривать наследования.

Класс по умолчанию неявно объявляет все пренадлежаще разделу `private`. Т.е. описанный выше класс стек неявно определен следующим образом.
```cpp
class Stack {
 private:
  int array[255];
};
```

Теперь становиться ясно почему мы не  можем вызвать поле этого класса напрямую, т.к. он закрытый. А почему мы можем так использовать структуру, потомочту она неявно объявлена как.
```cpp
class Stack {
 public:
  int array[255];
};
```

Ок, но мы упустили момент что мы объвили объект этого класса, это есть уже физическое представление нашего класса в памяти. Стоит заметить, что каждый объект типа стек имеет свое независимое сотояние от других объектов.
Ну про объекты много говорить нечего, это привычные переменные которые мы с Вами сто раз уже объявляли.

Ну у нашего класса есть маленький недочет, мы указали размер массива как литерал, давайте исправим это и объявим константу. Константы можно также объявлять в классе, как и обычную константу, но с одним ограничением.
Можно объявить `enum`
```cpp
class Stack {
  enum {SIZE_STACK = 255};

  int array[SIZE_STACK];
};
```

Тут еще есть важный момент то что SIZE_STACK принадлежит скопу Stack, так еще к нему нельзя получить доступ снаружи. Кул. Чтобы получить доступ надо enum вынести в public секцию. Но это детали реализации)

Мы знаем что есть такое крутое дело как `constexpr`, давайте втулим его в наш класс.
```cpp
class Stack {
  constexpr unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
};
```

Собираем получаем ошибку, что мол мы не правильно используем не статический мембер класса. What??? не статтический это что такое, при чем тут статика. А проблема в том что класс это просто описание, это не объект, а `constexpr` константа это компайл тайм выражение и она будет определяться(устанавливаться при компиляции). А что утанавливать если нет никакой памяти? Ок, скипаем такой вариант
Берем вариант с обычной константой, ведь говориться что привычная нам костанта объявлена с ключевым словом `const` может устанавливать значение в рантайме. Кул подходит, присвоим ей значение когда создадим объект.
```cpp
class Stack {
  const unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
};
```

Собираем, и тут нас ждет печаль, нам компилятор говорит что мы не правильно используем не статические мембер, т.е. мы его не можем записать как размер массива. Та шош то таке. Но это понятно если мы не можем устанавливать компайл тайм костанту, то мы и не можем создать массив какого размера нам надо создавать, т.е. какого размера будет полная структура в памяти. Т.е. тут есть еще плюс, то что мы благодаря такого подхода мы можем избавиться от так называемого переменного размера массива, с которым мы столкнулись при работе с массивами. Но тут еще ошибка что вы не можете указать размер массива полем класса (не статическим). Опять это не статическое. Ок, так что получаеться я могу объявить массив только  используя enum или литерал.
**Замечание** что таким образом инициализировать константы можно только начиная с С++11 стандарта. До этого вам необходимо инициализировать константу специальным образом, забегая в перед только через конструктор. Если мы запустим это пример с опцией для более новых компиляторов gcc -std=c++98, то получим предупреждение "*data member initializers only available with -std=c++11 or -std=gnu++11*"

Но можно также используя константу обявив ее в не класса. Но это нарушает инкапсуляцию, нашего класса.
Но нам компилятор подсказывает сам) используйте вы уже статические переменные!!!!. Т.е. инициализация возможна применяя static переменные. Давайте разшевилим нашу память о статике. `static` неважно где она объявлена, это тело класса, функции, да и просто так. Копилятор обрабатывает до выполнения всех других инструкций. Т.е. у него некий глобальный сторедж. Т.е. он не зависит от **количества объектов этого класса**. Т.е. `static` он уже используеться не для объекта, а рассматриваеться как принадлежащий классу, т.е. он есть экземпляром объекта(или правильно сказать память под него не выделяеться при каждом создании объекта). Он также как и `enum` пренадлежит только области класса, но память у него выделяеться не зависимо от объектов класса. И еще статика есть частью локальной линковки, она являеться локально на уровне файла не на внешнем уровне(глобальной).
Фух, разобрались, я надеюсь. Давайте это чудо добавим в наш класс.
```cpp
class Stack {
  static const unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
};
```

Собираем и о чудо все компилиться как надо. Но так можно объявлять интегральные константы, если такое чудо собрать применив к типу float (компилируя ее до С++11 го), то получим ошибку компиляции.
```cpp
class Stack {
  static const float SIZE_STACK = 255;
};
```

То получим следующую ошибку компиляции `ISO C++ forbids initialization of member constant ‘Stack::SIZE_STACK’ of non-integral type ‘const float’`, т.е. стандартом запрещено инициализация константных полей не интегрального типа. А если мы запустим с новым стандартом, то получим чудо другого вида `error: ‘constexpr’ needed for in-class initialization of static data member ‘const float Stack::SIZE_STACK’ of non-integral type`, смысл в том что если мы хотим не интегральный тип инициализировать константным выражением пиши `constexpr`. 
```
class Stack {
  constexpr static const float SIZE_STACK = 255;
  //int array[SIZE_STACK];
};
```

Собираем работает.
Проблема в большей степени, на мое мнение связано с тем что С++ не говорит как будет храниться(представляться) вещественное число на памяти, и это он предоставляет на усмотрения процессора.
Ну ок в первом случае нам компилятор сказал дядько возьми так и сделай, мы взяли так и сделали, компилятор то дядька умный. Так а шо делать то с первым, а дядька, ту он не говорит уже. Но говорит стандарт что в классе надо делать объявление константы, а определения с инициализацией выносить вне области класса. Дичь просто.
Но давайте взглянем что почем, немного вспомнив что такое интегральная константа и как компиятор вставляет вместо создание переменной вставляет вместо ее использования ее значения, таким образом делая некую оптимизацию. но если нам необходимо ее взять адресс, т.е мы будем использовать константу как переменную, нам ее нужно определить. Но компилятор не может определить статическую константу времени компиляции, т.к. класс не есть определения, это есть описание, т.е. сказать сколько будет памяти жрать наш класс. Но с вещественными числами дело то хуже, компилятор, или с++ понятия не имееют как будет храниться вещественное число в памяти, поэтому они не делают инлайнинг числа, как это делают с интегральной константой. Поэтому надо определить сказав компилятору как инициализировать это вещественное число. И **важно** определение может быть только одно (делают, так объявление в `hpp` файле а определение в `cpp` файле). Ого много всего. Давайте запримерим
```cpp
#pragma once

class Stack {
  static const float SIZE_STACK;
};

const float Stack::SIZE_STACK = 255;
```

Собираем и о чудо все воркает. Немного синтаксиса. Ну во-первых указание повторного `static` являеться не нужным, компилятор и так все понимает(помните он же умный дядько), тут добавляеться толь то что нужно указать что эта константа принадлежит классу `Stack`. Так же можно писать и интегральные константы, но вопрос зачем?)

### Методы класса
Ок, что мы имеем у нас есть объявление класса стека, которое состоит с одного только фиксированого размера доступ к которому мы не может получить, хотя копировать, т.е. присваивать между собой объекты класса стек мы можем. Ну это не решает проблемы. Но исходя икапсуляции мы молодцы, а вот теперь мы должны прийти к идеи абстракции. Т.е. мы должны предоставить публичный интерфейс для работы  с таким стеком.
Ок, начнем. Но прежде чем перейти к реализации мы должны определиться что наш класс стека должен предоставлять в качестве публичного интерфейса для работы со стеком.

1. Это добавление элемента в стек.
2. Это удаление элемента со стека.
3. Получения элемента с вершины стека.

Ок, так как эти методы писать? Методы это тежи функции, т.е. с той же логикой работы, только они принадлежат области класса в котором они определены. Что такое область в котором определены? Главное их свойство это возможность работы внутри этих метов с полями нашего класса, т.е. читать, модифицировать и т.д. Но есть и еще одно важное отличие. Для понимание этого мы вспомним как мы обращаемся к полям класса или структуры, неважно, мы через символ `.` это для обычного объекта или символа `->` для доступа через указатель получаем доступ к полю. Так вот чтобы вызвать метод принадлежащий этому классу, его надо вызывать так же как и получение доступа к полю, т.е. через теже специальными символы. Поэтому и говорят что метод принадлежит классу(есть правда немного отличия для статических методов). Но мы еще вернемся к методу детального рассмотрения.
Ок, давайте заимплементим эти методы внутри класса.
Сначало добавим метод добавления элемента в стек. Для этого немного покумекаем  в каких случаях у нас ошибочная вставка в каких мы успешно добавляем. Нам надо добавить еще одну переменную которая будет текущим положением указателя на вершину стека. Указатель это громко, но так как мы поднизом используем массив, то и быдем применять понятие целочисленого индекса. И тогда если мы добавляем элемент в стек и при этом наш указатель равен максимальному размеру стека, тогда мы не должны добавлять элемнт в стек, иначе мы добавляем элемент в стек и увеличиваем индекс вершины стека. *Ну еще одно уточнение* нам надо придумать что мы будем возращать пользователю нашего класса. Для этого я решил что мы будем возращать пару статус операции и сообщение. Для этого мы напишем свою структуру представляющей из себя пару. Можно было бы использовать готовую такую структу реализованную в тсандартной библиотеке, но зачем нам тянуть весь заголовочный файл, если у нас примитив для одного только типа.
Ниже приведен пример написанный в hpp файле
```
#pragma once
#include "common_type.hpp"

class Stack {
 public:
  Pair push(int value) {
    Pair res {false, ""};
    if (current_position == SIZE_STACK) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

 private:
  constexpr static unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
  int current_position;
};

```

Я думаю что объяснять зачем мы нашу функцию написали в разделе `public` не нужно. Но мы видим что мы перед нашими полями данных добавили явно секцию `private`, это сделано в связи с тем что секция ее область действия(шикарное словосочетание), распостраняеться до ближайшей другой секции. Исходя из моих слов каламбуров, то если мы явно не укажем `private` то наши данные будет публичные, т.к. мы выше объявили раздел `public`. Тут можно было и подругом пойти, т.е. вначале писать поля данные, а потом открытый интерфейс, в этом случае мне не пришлось бы писать секцию `private`. Но я придерживаюсь стиля написания, что вначале идут публичные данные, потом протектед, а потом приватные.
Вообщем с примера видно что в случае если мы не можем что то добавить на стек, мы возращаем ошибку, и наче мы возращаем статус ОК, и увеличиваем индекс стека. Как бы все ок. Но не забываем что мы такое объявили в hpp заголовчном файле, а внем писать реализацию метода, т.е. то что он делает не ок. В этом нет ничего плохого, просто если у вас таких методов будет 10, прикиньте как тяжело будет читать этот класс, просто пытаясь понять что предоставляет это класс как внешний интерфейс(да я знаю про сворачивание метод в IDE). Второй момент, если мы распотраняем этот код как библиотеку(а она будет бысмыслена если мы все заимлиментим в заголовочном файле), мы не хотим дядькам показать что делает наш код, если это крутая какаято сортировка, хотя крутые прогеры могут дезасемблировать, но короче не об этом сейчас. Мы просто разделяем что делает класс и как делает это класс на заголовочный и файл реализации. Т.е. при например написания библиотеки, объектрный код станет библиотекой, а заголовочный будет идти как часть интерфейса к библиотеке. Фух как много написал.
Давайте разделим.
**stack.hpp**
```cpp
#pragma once
#include "common_type.hpp"

class Stack {
 public:
  Pair push(int value);
 private:
  using TypeSizeStack = unsigned;

  constexpr static unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
  int current_position;
};

```
Как видим мы убрали реализацию, метода `push`, а оставили только его объявление. Ок, давайте добавим реализацию нашего метода в cpp файл.
**stack.cpp**
```cpp
#include "stack.hpp"

Pair Stack::push(int value) {
  Pair res {false, ""};
  if (current_position == SIZE_STACK) {
    res.msg = "Satck is full";
    return res;
  }
  array[++current_position] = value;
  res.status = true;
  res.msg = "Success add to stack";
  return res;
}
```   
Ок, что за `Stack::push`, у меня вызвал когда я первый раз писал классы. Тут мы видим различие между определением в классе и в отдельном модуле. Вся суть, если вспомнить, это то что методы принадлежат области класса. Т.е. таким образом, это некий сахар для компилятора он должен же понимать с какими вы полями можете работать а с какими нет, т.е если вы пытаетесь обатиться не принадлежащий этому классу полям. Т.е. таким образом компиялтор выполняет много проверок. Но есть вопросик, т.е. если он принадлежит этому классу, то значит наверное размер объекта должен же быть больше. Вопщем вопросов уу меня как в новичка было много. Но начнем с того что метод это таже функция, **она ОДНА**, метод не создаеться для каждого объекта, у нее только один адресс, она одна в памяти кода и все!!! Метод есть частью(сахар) класса. ОК, кэп сказал я, так а откуда он тогда понимает какие именно, верней сказать какие поля какого объекта он меняет???? АААА??? Тут С++ превзошел себя, методы в С++ вызываються по соглашению thiscall. Капец как все сложно, нет Вася, все просто) Это осначает что компилятор добавляет неявно еще один дополнительный параметер это указатель на объект который вызвал этот метод. И тогда в методе появляеться такой скрытый объект как **`this`**. Т.е. напишем наше тело функции, так как его применяет компиялтор
```cpp
Pair Stack::push(int value) {
  Pair res {false, ""};
  if (this->current_position == SIZE_STACK) {
    res.msg = "Satck is full";
    return res;
  }
  this->array[++(this->current_position)] = value;
  res.status = true;
  res.msg = "Success add to stack";
  return res;
}
```
Что это за .... Ок, сразу беру sizeof пустого класса в которм только объявлено одно поле `int` и метод который что то делает с этим полем, берем его размер класса, и только 8байт, это что за чепуха, где размер моего `this`, где его вообще компилятор его обявдяет. Ответ шикарен, нигде, его в классе нет!. Попорядку. Я говорил что соглашение о вызове есть такое `thiscall`, прикол в том что при вызыве метода, пример такой
```
  Stack st;
  st.push(90);

```
Компилятор сделает вот такую гадость
```
 Stack st;
 push(&st, 90);
``` 
Т.е. он передает туда неяввно указатель на объект который вызывает этот метод, тогда становиться понятно какому объекту мы меняем данные. Если попытаться так вот вызвать метод, как возможную генирацию, то мы получим ошибку(наверное что нет такой функции). Так мы только вызовем получив указатель на этот метод. И тут мы опа приходим еще к одной части, это то что указатель на функцию отличаеться от указателя на метод, и понятно это доплнительным параметром.
Ну если в метод передаеться указатель `this`, как скрытый указатель, то стало быть можно вызывать метод с null указателем, если в методе нет работы с данными классами. Давайте попробуем это будет как тест.
```cpp
#include <iostream>

class Stack {
 public:
  ....
  void test() {
    std::cout << "test" << std::endl;
  }
 private:
  ...
};

// и вызов
int main(int argc, char const *argv[]) {
  ...
  Stack* ptr;
  ptr->test();
  return 0;
}

```

Это некое доказательство того что я вам распинаясь пытался рассказать. Т.е. как видим, мы по null указателю вызвали метод, с этого следует то что метод это просто сахар реализуем компилятором, не более того. Но **важно** если вы в этот метод добавите поле то программа у вас упадет, так под поля класса память то небыла выделена.
**Забыл** Но есть еще разница между тем что мы разносим объявление и реализацию по разнеым файлам, это то что определив функции  внутри класса, без вынесения его определения наружу, такой метод становиться `inline`(на помните, что если в метод неастрочете 100 строк кода, то вам его никто не заинлайнит, компилятор умный дядька помните это).
Ок, начитавшись теории давайте добавим еще один метод это удаление элемента с верщини стека. Я буду делать дальше объявление в заголовочном файле а реализацию в cpp.
**stack.cpp**
```cpp
Pair Stack::pop() {
  Pair res {false, "Stack empty"};
  if (current_position == -1) {
    return res;
  }
  --current_position;
  res = {true, "Success"};
  return res;
}
```
Ок, я думаю ту еще все проще, проверяем если стек пустой, то возращаем ошибку, иначе уменьшаем интекс стека на дно).
И получение элемента с вершины стека. 
```
Value Stack::top() {
  Value res {false, 0};
  if (current_position == -1) {
    return res;
  }
  res = {true, array[current_position]};
  return res;
}
```

Просто все до немогу) проверяем что не пуст ли стек, если да то ретурн ошибочку, иначе возращаем значение на вершине стека. Мы добавили новый тип, возращаемое значение с вершины стека, содержащее статус, и значение.

Если посмотреть немного внимательный на этот метод, и вспомнить что ООП представляет состояние объекта, т.е. вызвав метод мы не знаем что там на самом деле происходит если это скрыто реализацией, например библиотеки. И хотелось бы глядя на интерфейс этого класса быть увереным что если он описан как не меняющий состояние объекта, то он не должен его менять. Правильно сказать чтобы не было побочных эфектов. Возращаясь к нашему методу, мы можем увидеть, что он просто берет на вершине стека значение и возращает его. Т.е. этот метод не меняет состояние объекта, а как нам гарантировать что вызвав этот метод, объект не изменит свое состояние, не просто написав описание, а гарантировать на уровне языка. Для  этого случая применяют так называемые const методы. Смысл их в том что внутри этих методов мы можем читать только поля класса, но не менять их. Запутано согласен. Дальше еще хуже). Идея const методов в том что они явно гарантируют целостность объекта, и не изменяемость состояния объекта. Но еще что хуже внутри этих методов можно вызывать только такие const методы, но это логично. Короче давайте перепишем наш метод `top` сделав его константным.
```cpp
class Stack {
 public:
 ....
  Value top() const;
 private:
 ...
};

Value Stack::top() const {
  ...
}
```
Как видим наше объявление и определение метода немного изменилось, мы добавили `const` в конец метода, который есть теперь частью интерфейса. То теперь читающий наш код, увидит определение нашего класса, посмотрит публичный интерфейс нашего класса, и посмотрев на метод `top` он будет уверен что вызвав этот метод никаких побочных эфектов не будет.
Ок, но это не все на счет const метода, они еще играют роль когда объявляються объекты класса стек. Суть в том что объявив объект как константный мы можем вызывать только константные методы, тогда как не константные объекты могут вызывать как константные методы так и обычные. А почему должно появиться в голове у каждого вопрос, т.е. как компилятор будет гарантировать не изменяемость объекта, ведь как мы выше рассмотрели функция она одна и вызываеться для всех объектов. А сахар то в том, какой туда приходит `this`, **он там есть как указатель на const**. Все так просто.

Как бы все наш класса стека готов давайте будем тестить
```
#include <iostream>
#include "stack.hpp"

int main(int argc, char const *argv[]) {
  Stack st;
  st.push(90);
  st.push(100);
  std::cout << st.top().value << std::endl;

  st.push(1);
  std::cout << st.top().value << std::endl;
  st.pop();
  st.pop();
  std::cout << st.top().value << std::endl;
  st.pop();
  auto value = st.top();
  if (value.status) {
    std::cout << value.value << std::endl;
  } else {
    std::cout << "Stack is empty" << std::endl;
  }
  auto res = st.pop();
  std::cout << res.msg << std::endl;
  res = st.pop();
  std::cout << res.msg << std::endl; 
  return 0;
}
```

И если мы выполним этот код, то увидем не то что мы ожидаем.
```
100
1
90
0
Success
Stack empty
```

Т.е. видим что у нас траблы с индексом, что то в коде мы не так сделали. Т.е. мы добавили три элемента в стек, получили то что ожидаем, потом вытолкнули, получили какойто 0, а должны получить ошибку.
Ок, я думаю что в этом коде полноценно не хватает двух еще методов. Первый этот возращающий нам вообще капасити нашего стека(другим словом максимальный размер). Второй это текущее положение нашего. Начнем со втрого, так первый немного требует вводной воды.
Т.е. нам надо реализовать метод который вернет нам текущее положение индекса. Ок, все просто, но мы уже с Вами прокачены немного в понятии метода, и мы делаем анализ и понимаем, что этот метод хороший кандидат на константность, т.к. он не меняет состояние объекта, он просто возращает значение индекса стека. Ок, с этим разобрались.
```cpp
class Stack {
 public:
  ...
  int GetCurrentPosition() const;
  ...
};

int Stack::GetCurrentPosition() const {
  return current_position;
}
```
А что на счет первого, он тоже может быть константным, он тоже не меняет состояние объекта, скажут все. Оно таки то да, но посмотрев на реализацию нашего класса, мы видим и вспоминаем что размер то стека есть статическое поле. Т.е. то поле которое не есть частью объекта а есть частью класса. Верней он храниться в памяти в единственной копии и **что важно не влияет на размер объекта в памяти**. Т.к. у него другой сторедж. И мы тут же вспоминаем что метод мы как бы не можем вызвать без объекта(все в голове держат указатель this). То для статической переменной хотелось бы иметь такой метод который можно было бы вызвать не зависимо от объекта, т.е. на уровне класса. Банально как то так `Stack::Size()`. Понимая это можно так получить то что все объекты между собой разделяют в единственной копии. Для этого применяют статические методы. Т.е. методы к объявлении которых добавляеться ключевое слово `static`. Как много этих методов, нет это только начало. Мы тут же вспоминаем что мы такое уже рассматривали, мы объявляли статические функции, суть которых в том что они имееют статическую линковку, т.е. они видны только в одном модуле трансляции, и не видны другим модулям программы. Т.е. они статические для конкретного модуля. То для статических методов, это совсем несет другой смысл.
Статические методы, это те же обычные функции, т.е. у них нету скрытого параметра `this`. Ну и это понятно ведь они работают на уровне класса. Статические методы полезны тогда когда мы что то хотим создать не нуждаясь в екземпляре класса. Статические методы еще имеею важную особоеность они могут получать тот же доступ к приватным полям класса, только передав явно туда объект(я думаю все понимают зачем).
Ок, после всей этой воды, мы уверено говорим что метод для получения размера стека, мы объявляем как статический. Ведь нам надо вернуть константу размера стека, которую разделяют между собой все объекты этого класса.

```
class Stack {
 public:
  ...
  static unsigned GetMaxStackSize();
 private:
  constexpr static unsigned SIZE_STACK = 255;
  ...
};


unsigned Stack::GetMaxStackSize() {
  return SIZE_STACK;
}

```

Вообщем все просто. И на этом можно было бы закрывать первый наш эта написания класса Stack. Но мы то продвинутые программисты, и хочем писать качественный код. Давайте внесем некотоую косметику в наш код. А именно меня раздражает тот факт неявного преобразования типов в С++, ведь у нас то стек целого типа `int`. И хотелось бы присваивать туда значения которые могут поместиться в этот тип. А запретить например `long int`, `float`, `doouble`, `long double`. Вернувшись к разделу о функциях и пергрузках мы вспоминаем как это надо делать. Т.е. есть два способа, это сделать объявление и не писать определение, но как по мне полная ... Но начиная с С++11 есть новая тема а имеено понятие удаляемости функций(= delete). О годиться, давайте напишем объявление этих функций как удаляемые.
```cpp
class Stack {
 public:
  Pair push(int value);

  Pair push(unsigned int) = delete;
  Pair push(long) = delete;
  Pair push(long long) = delete;
  Pair push(float) = delete;
  Pair push(double) = delete;
  Pair push(long double) = delete;
  ...
};
```
Как видим все просто пишем просто объявление и добавляем ключевое слово `delete`. И теперь попытаемся, добавить элемент например вещественный в стек, то получим ошибку компиляции.
```cpp
...
st.push(100.20);
``` 
error: use of deleted function ‘Pair Stack::push(double)’
```

Круто, мы не только реализовали функцилнальный стек, но и еще безопасный.

```

### Деструкторы и контсрукторы.
Теперь вернемся к нашему багу. Как бы все ок, класс работает объекты создаються, можно даже их друг другу присвваивать. Иногда даже непонятно как это происходит, ведь у нас есть массив, а мы как знаем с курса о массивах, то массивы нельзя друг другу присваивать. Но то как говориться потом. Давайте с бага начнем. Если копнуть наш класс, то мы увидим, что условием проверки пуст ли стек есть `if (current_position == -1)`. Ок, я думаю во многих возник этот вопрос когда мы проэктировали наш класс, а вопрос такой чему же равно начальное занчение этой переменной. Если взять аналогию со структурой, то мы вспомним что если явно не проинициализировать структуру, то получим муссор. Ок, так как нам вывести то поле текущего индекса, ведь оно приватное, а для этого у нас есть метод `Stack::GetCurrentPosition()`. Ну давайте его вызовем в начале после создания объекта.
```
  Stack st;
  std::cout << st.GetCurrentPosition() << std::endl;
```

На экране мы получим 0. Т.е. не понятно, как в структуре муссор, а в классе 0. Все дело в том что если объявлять структуру как POD тип, то компилятор ее оптимизирует и рассматривает как старую добрую С структуру. А класс это класс, это уже сущность языка С++ и у нее свои правила.
Ну короче, скажете вы, так кто же устанавливает 0 нашему полю? Для этого для классов С++ генерирует и применяет такое понятие как конструкторы и деструкторы.
В двух словах что это такое. Это тежи функции, но не теже, у них есть четкое правило они имеет такое же имя функции как и имя класса, и не иммеют возращаемого значения. А зачем это, и как если это функция то нет возращаемого значения. Да все просто, его идология быть близкой к тематике встроенных типов, вот и все. Т.е. получаеться что какимто образом компиятор неявно создает функцию конструктор, которая и инициализирует наши переменные. Но чтобы перейти дальше, **важный момент** то что компилятор не просто гененрирует методы эти по умолчанию, а еще выполняет некую скрытую магию за нас(это будет более понятно при рассмотрении наследования, и виртуальных функций), например выделяет память под наши поля класса, инициализирует их началным значение, и делает выравнивание этих полей. Но нас сейчас как раз именно интересует инициализация полей. Как было сказано выше это происходит благодаря тому что компилятор неявно добавляет нечто в наш класс.
``` cpp
class Stack {
 public:
  Pair push(int value);
  ....
  static unsigned GetMaxStackSize();
  Stack() = default;
  Stack(const Stack& st) = default;
  Stack& operator= (const Stack& rhs) = default;
  ~Stack() = default;
 private:
   ...
};

```
Т.е. компилятор неявно генерирует, два конструктора(если быть честным то 3и, но так как мы не рассматриваем оперетор перемещение, то опустим его описание).
1. Это конструктор по умолчанию, смысл его в том чтобы иницализировать поля ихними дефолтными значениями. Т.е. например, `int` присвоить ноль, указатель инициализировать null и т.д. Вот как раз он и вызываеться для инициализации наших полей. Т.е. в нешем случае это
```cpp
  Stack st;
``` 
2. Конструктор копирования, суть его проста до немогу, а имено **инициализировать** новый объект значениями уже существуещего объекта. Ну еще чтобы более было ясно, это то что бы вести себя как встроинные типы.
```cpp
 Stack st;
 Stack cp_st {st};
 // это аналогично
 /*
 int a = int();

 int b(a);
 */
```

А почему не возращает значение, так а зачем если он и так конструирует наш объект. Но ок, веренемся к нашему примеру, так а как нам инициализировать наш индекс другим значение, отличным от нуля. Ну ок давайте попробуем инициализировать его в теле этого конструктора как привычная нам работа.
```
  Stack();

Stack::Stack() {
  current_position = -1;
}

```

И запущаем, и вуаляяяя, мы получили тот результат который мы ожидали от стека.
```
-1
-1
100
1
90
Stack is empty
Stack empty
Stack empty
```

Как видим с результата вывода на консоль, то начальные значения индекса теперь -1, и последний элемент у нас 90, а при попытке вытолкнуть элемент со стека то мы получим сообщение что стек пуст.
Тут **надо подметить** что мы убрали `default` при объявлении конструктора, тем самым сказали что мы сами решим как мы хотим. 
Как бы все ок, но есть подводный камень об который сталкиваються новички. Это так называемый список инициализации.
Все дело втом в каком порядке у нас все это дело вызываеться. Я же говорил что магия происходит компиялятором. А все дело в том что до вызова конструктора сначало выделяеться память под поля класса, **и важно в том порядке в котором они объявлены**, и инициализируються дефолтным значением. Т.е. в нашем классе, как мы написали инициализацию поля, то получаеться мы ей устанавливаем значение два раза. ААААА дичь! А как ей инициализировать один только раз, но тем чем мы хочем. То для этого и используються списки инициализауции. Давайте нарисуем их сразу
```
Stack::Stack()
 : current_position (-1) {
}
```
Конструкция проста до ужаса, мы просто добавили после конструктора двоеточие и указали начальное значение для нашего индекса. Этим способом мы указываем что мы инициализируем наш индекс один раз до момента выполнения тела функции. А что на счет он массива, он инициализируеться неявно, дефолтным значением, как и прежде. Т.е. компилятор все равно за нас выполняет магию) На то он и компиялтор(умная зараза).
**Важно** поля инициализируються в том порядке в котором они объявлены в классе
```cpp
class Stack {
 public:
 ...
 private:
  constexpr static unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
  int current_position;
};
```

Т.е. в нашем случае будет проинициализирован неявно массив, а потом наш индекс. А что на счет статической переменной, то помним что она не ясть частью объекта, и определяеться и инициализируеться до всех объектов класса.
Но стоит сказать то что мы сделали было актуально до С++11, а начиная уже с С++11, можно применять инициализирующее выражение  для полей класса. **Важно** инициализирующее выражение применяеться только если инициализирующее выражение есть постоянное, т.е. применяеться как в нашем случае для конструктора по умолчанию. Но если например у нас есть конструктор инициализации с несколькими параметрами, т.е. инициализация может быть разная, то лучше его неприменять. В соответсвии с Core Guidline, рекомендуенеться применять инициализирующее выражение вместо конструктора по умолчанию.
В нашем примере это
```cpp
class Stack {
 public:
 ...
 private:
  ...
  int current_position = -1;
};

``` 
Ну поздравляю это наш простой класс стек, с минимально необходимым функционалом.
Но как по мне в этот класс надо добавить возможность чтобы стек был динамическим, т.е. когда мы создавали экземпляр этого класса, мы могли указать какого он будет размера, т.е. вместо статического размера мы указали динамический.
Так что для этого нужно, а нужно нам избавиться от статического поля указывающий статический размер класса и  самого массива. А вместо этого сделать динамический массив. Т.е. удалить поля
```cpp
  constexpr static unsigned SIZE_STACK = 255;
  int array[SIZE_STACK];
```

И добавить указатель на `int`
```
class Stack {
 ...
 private:
  int* array;
  int current_position;
};
```

И попытаемся собрать наш класс, то получим еще одну ошибку компиляции, указывающая что нет определение переменной `SIZE_STACK`. Ну это понятно, мы ее удалили. Но теперь мы понимаем что удалив статический размер стека, нам надо добавить переменную которая будет константа содержащая максимальный размер стека именно для конкретного объекта. Т.е. константа времени выполнения. Ок добавим эту переменную.
```cpp
class Stack {
 public:
 ...
 private:
  ...
  const unsigned SIZE_STACK;
};
```
Ок, не выдумывая ничего с название, используем старое, т.е. теперь вместо статической переменной у нас стала переменная экземляра класса. Собираем иииии, ошибки(. Получаем ошибки, их еще больше стало.
Ну первая это то что сравнение знакового и без знакового, но давайте поменяем тип на беззнаковый я просто не люблю преобразования.
```cpp
class Stack {
 public:
 ...
 private:
  ...
  const int SIZE_STACK;
};
```

Ок, от ворнинга избавились. А вот следующая ошибка это неправильное использования переменной `Stack::SIZE_STACK` в тсатической функции. Ну это понятно, вспомнив что статческие функциям не передаеться скрытый объект `this`, т.е. он являеться частью класса а не объекта, и соответсвенно может иметь доступ только к статическим переменным. Давайте ее перепишем с статической на константную(я думаю понятно почему константную).
```cpp
int GetMaxStackSize();

int Stack::GetMaxStackSize() {
  return SIZE_STACK;
}
```

Ок, собираем, теперь одна только ошибка, но какая. А суть ее в том что у нас не инициализированная константная переменная, и на самом деле, если вспомнить то мы знаем что константа должна быть инициализированная при создании. И тут компилятор такй хоп, а чем я ее буду инициализировать, ну есть у меня конструктор по умолчанию, а кокое значение должео быть для константы 0 или 1 или 2. И тут компилятор просто говорит короче сам решай какое должно быть значение, для этого мы должны сами установить значение константной переменной. А вопрос где ее устанавливать. В теле функции? Ответ нет, так как мы знаем что в теле мы иниицализируем уже проинициализированную переменную, т.е. это повторная инициализация. Тогда где, ответ очевиден, это список инициализации (я думаю понятно почему). И еще можно явно указать в инициализирующем выражении для поля. Я буду придпочетать вторй вариант так как он следует Core Guidline.
```cpp
class Stack {
 ...
 private:
  ...
  const int SIZE_STACK = 5;
};
```

Ок, но у нас немного уродски получаеться что мол константа устанавливаеться в поле инициализации, а индекс в дефолтном конструкторе. Вообщем давайте удалим дефолтный конструктор, и инициализируем переменные прям порядке инициализации поля. И пусть компиялтор генерирует лучший, отимизированный конструктор.
```cpp
class Stack {
 public:
 private:
  int* array = nullptr;
  int current_position = -1;
  const int SIZE_STACK = 5;
};

```

И удалим с кода все следы дефолтного конструктора. Собираем и бух, ошибка мол типа нет определения конструктора по умолчанию. Шо мы же удалили и решили компиялтор сам это генерируй. А проблема то встрочках
```cpp
  Stack(const Stack& st) = default;
  Stack& operator= (const Stack& rhs) = default;
  ~Stack() = default;
```

Указав таким способом какие мы хотим генерировать по умолчанию конструкторы, деструкторы, компилятор умывает руки от генерации дефолтного конструктора, так как он считает что вы явно указали что вы хотите что бы он генерил. Если удалить х из кода, и еще раз попытаться собрать то все у нас успешно скомпилиться.
Ок с этим разобралиьсь, так а как нам передавать меняющеся значение для константы. Давайте без лишних слов, для этого используються конструкторы со списком параметров(ненашел другого подходящего названия). Т.е. нам нужен конструктор принимающий один параметр а иммено размер нашего стрека.
```cpp
Stack(int size)

Stack::Stack(int size)
: SIZE_STACK(size) {
}
```

Собрираем наш код и получаем ошибку компиляции, т.е. компилятор не может вызвать дефолтный конструктор, а предлагает альтернативные конструкторы. В данном  случае наш новый с одним парметром. А что тут происходит, а суть ее в том что если мы явно указали конструктор с параметром, то компилятор перестает генерировать дефолный конструктор, так как он не знает что туда писать, он то знает, просто он думает раз ты решил сам написать такой конструктор, то флаг тебе в руки я ничего больше делать не буду, как то так.
А хотим мы дефолтный. Ну я например нехочу. Давайте тогда если мы не хотим чтобы нащ класс имел дефолтного конструктора, давайте явно об этом скажем и не толкьо компилятору, написав при этом ключевое слово `delete`, помните о таком.
```
Stack() = delete;
```
то при попытке собрать наш код поллучим уже читающий код что мол мы пытаемся вызвать конструктор который удален.
УУУУ кул мы стали еще круче. Так а что теперь с указателем, нам надо где - то выделить память. А где это надо делать? Тут два варианта, один из которых я не фанат, а предпочитаю больше другой. Начнем с первого. Все мы понимаем что если мы создаем наш динамический массив, то его можно создавать написав например функцию `Allocate`, но не мне не очень к тому же источник ошибок, а если мы ее забудем вызвать, а вызвем например функцию получения элемента  с вершины стека. То можем получить, а не не получим ведь мы правильные программисты, и пишем тесты на наши функции). Но да ладно, мы это сделаем в конструкторе, т.е. при создании объекта мы динамически выделим память под стек, и нам не надо париться когда нам надо вызвать фкункцию алокации памяти, за нас это сделает могущий компилятор. Нус приступим.
```cpp
Stack::Stack(int size)
: SIZE_STACK(size) {
  if (SIZE_STACK > 0) {
    array = new int [SIZE_STACK]{};
  }
}
```

Как  видим с примера все просто мы проверяем больше ли единицы наш размер запрашиваемого выделения стека. И если все ок, то выделяем память под стек. Но тут моментик есть, мы не можем как в других функциях возращать стату, ведь конструктор то ничего и не возращает. Ну ок, супер теперь тестируем.
```
#include <iostream>
#include "stack.hpp"

int main(int argc, char const *argv[]) {
  Stack st{10};
  std::cout << st.GetMaxStackSize() << std::endl; 
  std::cout << st.GetCurrentPosition() << std::endl; 
  Stack st_more{20};
  std::cout << st_more.GetMaxStackSize() << std::endl; 

  st.push(10);
  std::cout << st.top().value << std::endl; 
  st.pop();
  std::cout << st_more.GetCurrentPosition() << std::endl; 

  std::cout << st.pop().msg << std::endl;

  return 0;
}
```
Ок, запускаем проверяем работает, размер стека для разных объетов разный. Круто. Но добавления динамики добавляет еще массу проблем. Первая из них это то что надо удалить выделеный массив, т.е. за собой почистить. И для этого как раз и пригодиться нам деструктор.
Деструктор это противоположность конструктора, т.е. он вызваеться когда о у нас удаляеться объект, правильно будет сказать разрушаеться. Т.е. выходит с области видимости, это для автоматической области, или мы явно удаляем его выделеного на куче.
Ну в отличие от разнообразия конструкторов то дееструктор может быть только один. **Важно** деструкторы не принимают параметров.
Ок теперь понятно, давайте добавим в деструктор удаление массива.
```cpp
~Stack();

Stack::~Stack() {
  if (array != nullptr) {
    delete [] array;
  }
}
``` 
Деструктор иммет такое же имя как и имя класса, но с добавлнеим символа `~`. Нуи запускаем на сборку нашу программу. Ок, отлично все работает. Таким образом в конструкторе мы выделяем память а в деструкторе ее освобождаем. Гуд) Таким образом мы с Вами реализовали идиому RAII получение ресурса есть и иницализация Resource Acquisition Is Initialization (RAII). Идея его заключаеться в том чтобы не забыть очистить за собой ресурсы, то в конструкторе происходит захват этого ресурса, а в деструкторе его высбождение. Т.к. деструторы вызываються автоматически после выхода с области видимости, то мы гарантированно осбодим память(небудет memory leaks).
Класс, у нас как бы получился отличный класс, но взглянув на реализацию деструктора, и остальных функций, то мы видим что у нас может быть seg fault, так как указатель может быть null. Ок, исправим это добавим проверку указателя во всех методах.
```cpp
Pair Stack::push(int value) {
  Pair res {false, ""};
  if (nullptr == array) {
    res.msg = "Stack is not allocated";
    return res;
  }

  if (current_position == SIZE_STACK) {
    res.msg = "Satck is full";
    return res;
  }
  array[++current_position] = value;
  res.status = true;
  res.msg = "Success add to stack";
  return res;
}

Pair Stack::pop() {
  Pair res {false, "Stack empty"};
  if (nullptr == array) {
    res.msg = "Stack is not allocated";
    return res;
  }
  if (current_position == -1) {
    return res;
  }
  --current_position;
  res = {true, "Success"};
  return res;
}

Value Stack::top() const {
  Value res {false, 0};
  if (nullptr == array) {
    return res;
  }

  if (current_position == -1) {
    return res;
  }
  res = {true, array[current_position]};
  return res;
}
```

Как видно мы добавили в методы `push`, `pop`, `top` проверку не нулевой у нас ли указатель.
Супер работаем теперь с нашим классом. О а у меня есть идея давайте добавим инициализацию нашего стека на основе уже существующего стека, т.е. для этого нам надо написать конструктор который будет принимать такой же объект стека, но уже готовый, и мы его проинициализируем этим объектом, при этом передаваемый объект мы менять не будем(он должен быть константным). Для этого и применяеться конструктор копирования. Давайте его реализуем.
```cpp
Stack(const Stack& st);

Stack::Stack(const Stack& st)
: current_position(-1),
  SIZE_STACK(st.SIZE_STACK){
  array = new int[SIZE_STACK];
}
``` 
Все как бы ок, но меня смущает то факт что мы делаем практически тоже самое, как в пользовательском конструкторе. А давате сделаем вызов в конструкторе копирования пользовательский конструктор. Забегая наперед, скажу что вызов конструкторы, из другого конструктора появилась начиная с С++11, до этого писали некие `Init` методы. Ну ок, перепишем. Но гайс, стоп, а где его вызывать?? Хороший вопрос, наверное в теле конструктора копирования, это же как бы той же самый объект. Но это ошибочно. Пример
```cpp
Stack::Stack(const Stack& st) {
  Stack(st.SIZE_STACK);
}
```
Это частая ошибка новичков, в этом коде мы просто создаем временный объект и все, его время жизни до `;`. И он некак не повлияет на наш создаваемый объект. А как правильно, а правильно использовать список инициализации.
```cpp
Stack::Stack(const Stack& st)
 : Stack(st.SIZE_STACK) {
}
```

Таким способом вы говорите что создай объект используя другой конструктор, а потом выполни тело этого объекта.
Используем
```cpp
#include <iostream>
#include "stack.hpp"

int main(int argc, char const *argv[]) {
  Stack st{10};
  std::cout << st.GetMaxStackSize() << std::endl; 
  st.push(101);
  std::cout << st.top().value << std::endl;
  Stack st_more{st};

  std::cout << st_more.GetMaxStackSize() << std::endl; 
  if (st_more.top().status) {
   std::cout << st_more.top().value << std::endl;
  } else {
    std::cout << "Stack is empty" << std::endl;
  }
  

  return 0;
}

```

Как видно из примера, то мы вызвали конструктор копирования, и видим что размеры их совпадаю, а вот содержимое стека нет. Но есть еще одно чудо, если мы закоментируем конструктор копирования, то код у нас собереться без всяких проблем. Так зачем мы это все писали, пусть сам компилятор это за нас сделает. Суть в том что даже если мы объяявили пользовательськие конструкторы(конструктор с одним параметром размер стека), то компилятор все равно генерит конструктор копирования. Но не такой как мы хотим. При генерации дефолтного конструктора копирования, происходи просто побитовое копирование полей одного класса в другой. Но если посмотреть реализацию класса, то увидим что есть маленький трабл, а именно то что мы скопируем просто указатели а не содержимое стека, и в этом случая у нас будет два указателя указывать на одну и туже область памяти. То при выходе объекта с области видимости, мы будем в деструкторах обоих объектов удалять одну и туже память. А это есть неопределенное поведение.
Ок, а если мы захтим например присвоить один объект другому, что нам для этого надо. Нам необходим метод который будет принимать один объект являющиеся левой частью опретора `=`. И внутри мы должны все скопировать содержимое одного одних полей в содержимое других другого объекта. Но мы помним что в начале компилятор генерить 2 контруктора неявно, и еще один важный это опрератор присваивания. Т.е. нам не надо писать никакой метод, компилятор все за нас это делает. Давайте попробем например присвоить объекты друг другу.
```cpp
  st_more = st;
```  
И чудо компилятор при таком присвоении выдаст нам ошибку!!!!! Какой же он сейчас красавчик, такого раньше не делал.
```cpp
main.cpp: In function ‘int main(int, const char**)’:
main.cpp:18:13: error: use of deleted function ‘Stack& Stack::operator=(const Stack&)’
   st_more = st;
             ^~
In file included from main.cpp:2:0:
stack.hpp:4:7: note: ‘Stack& Stack::operator=(const Stack&)’ is implicitly deleted because the default definition would be ill-formed:
 class Stack {
       ^~~~~
stack.hpp:4:7: error: non-static const member ‘const int Stack::SIZE_STACK’, can’t use default assignment operator
```

А суть этого шлака в том что мы не можем изменить контсантное поле размер массива. А почему, а все потому что этот опрератор вызываеться когда есть уже два готово свормировавшиеся объекты, а мы знаем что константы присваивать нельзя они инициализуются только один раз. Огонь. А давайте ради экперимента изменим поле размера массива на не контантное значение. И соберем нашу программу.
```
  int SIZE_STACK = 5;
```

И все у нас отлично собираеться, т.е. компилятор за нас сгенерил оператор присвоение. Огонь. А такой ли он как нам надо? Запускаем программу и все ок работает. Но это неправильное поведение, если посмотреть описания оператора присвоение, то мы увидимм что он делает ровно то что делает дефолный конструктор копирования, а именно побитово копирует поля. Т.е. в нашем примере после присвоение одного стека другому мы получим что оба стека ссылаються на одну и туже область памяти. Но в нашем случае нам повезло, но в продашен коде, или в более больших программах, такого не случится у нас больше всего что программа свалиться, на попытке удалить два раза один и тот же объкт. Нам это не подходи давайте его перепишем.
```cpp
Stack& operator=(const Stack& st);
Stack& Stack::operator=(const Stack& st) {
 if (array != nullptr) {
   delete [] array;
 }
 current_position = st.current_position;
 SIZE_STACK = st.SIZE_STACK;
 array = new int[SIZE_STACK] {};
 for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
   array[i] = array[i + 1];
 }
 return *this;
}
```

Как видно с реализации, то оператор присваивания, отличается от других неявно сгенерированых методов класса.
Начнем попорядку
1. Оператор присвоение в отличие от конструкторов возращает значение, а иммено объект находящийся справа от знака `=`. Это сделано для того чтобы присвоение объектов было подобно поведению встроенных типов (`a = b = c`). Если честно вы можете возращать что хотите, возвращение объекта это лишь соглашение.

2. В нашем примере мы должны сначало очисть прежнюю выделенную память а потом, присвоить ей уже новую. Это важно чтобы не было утечки памяти.

3. Имя оператора присваивания начинаеться с ключевого слова `operator` и дальше идет оператор который мы собираемся перегрузить. О новое слово, да таким способом мы делаем перегрузку оператора, т.е. мы говорим компилятору что если ты встретишь выражение где один объект приваивает значения другого объекта, то найди в в класса перегрузку которя это делает. Детально мы об этом потом поговорим.

4. Вы можете писать как возращаемое значение, так и входной парметр, как вам угодно. Но помните, что этим же вы меняете смысл этого оператора, который привычный для других. Есть некое соглашение, и вы его должны следовать, а не компилятор.

Супер но есть большое НООООО!!!. А то что если мы например попытаемся присвоить значение самому себе. Типа
```cpp
 st_more = st_more;
```

То  все понимают что произойдет, а тот кто не понимает. То у нас будет ситуация, когда мы удалили память, того же объекта, потом иннициализируем стек муссором. В данном примере то нет ничего критичного, но зачем нам удалять память а потом ейприсваивать муссор. Ой, а как это поправить. Смотрим что у нас есть у нас есть присваиваемый объект с левой стороны, и есть указатель this которыйй указывает на объект справа. Огонь, что уже есть. Так давайте просто сравним их адресс, тем саммым мы убедимся что они ну указывают друш на друга.
```cpp
Stack& Stack::operator=(const Stack& st) {
 if (this == &st) {
   return *this;
 }
 
 if (array != nullptr) {
   delete [] array;
 }
 current_position = st.current_position;
 SIZE_STACK = st.SIZE_STACK;
 array = new int[SIZE_STACK] {};

 for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
   array[i] = array[i + 1];
 }
 return *this;
}
```

Как видим мы просто в начале добавили проверку самого на себя. Круто.
А тепь уже точно можно сказать что у нас есть полноценно, хороший стек.