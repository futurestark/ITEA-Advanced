# Наследование
Наследование есть еще одно из чертырех китов ООП. Смысл его в том чтобы класс(или в терминах ОПП абстрактный класс), наследовал характеристики(свойства) и поведение существуещего класса, ввиде открытого интерфейса.
Как видим идея наследования показать как отношения между классом. Например есть класс человек, который обладает следующими характеристиками как имя, фамилия, возраст, и есть класс студент, который есть разновидностью класса человек. Еще такое отношение называеться "являеться" это когда студент есть подобъектом класса человек. Т.е. любой студент есть человек, но не каждый студент есть человек.
Другое применение, которое чаще применяеться, это вынесение общего кода в общий класс, а другие классы наследуют это общее поведение.

## Наследование в С++
Простой пример наследования
```cpp
#include <iostream>

class People {
 public:
  void print() {
    std::cout << id << " " << age << std::endl;
  }
  People(unsigned id, unsigned age)
   : id(id), age(age) {
    
  }
  People()
   : id(0), age(0) {
    
  }
 private:
  unsigned id;
  unsigned age;
};

class Student: public People {
 public:
  Student(unsigned id, unsigned age, unsigned group)
   : People(id, age), group(group) {

  }
  void print() {
    People::print();
    std::cout << group << std::endl;
  }
 private:
  unsigned group;
};

int main(int argc, char const *argv[]) {
    Student student(100, 21, 10);
    student.print();
    return 0;
}

```
Это простейший пример наследования, но в нем расскрываеться многие важные аспекты наследования. Ну для начала мы определили класс People, который характеризует человека с характеристиками `id` идентификатора и `age` возраст, и один метод для печати этих характеристик. Этот класс не чем не отличаеться от привычных нам объявляемых ранее классов.
А вот второй класс Student отличаеться от привычных нам классов которе мы встречали ранее. в нем есть новая строка а имеено
`class Student: public People` - в ней мы говорим что класс Student наследует характеристики в данном случае поля и методы класса People. Это грубаая формулировка. Важной особенностью есть инструкция `public People` это означает открытое наследование. Давайте расммотрим все типы наследования. Но для начало определимся еще в терминологии People это базовый класс, Student это производный класс.
**Публичное наследование** `public` при таком типе наследования все публичные поля базового класса доступны в производном классе и для внешнего мира. Все `protected`, мы добрались до этого индетификатора доступа, все данные объвленные в этой секции не доступны из вне, но доступны производному классу. Но все приватные поля базового класса не достпны не в производном не окружающему миру(инкапсулиция). Этот тип наследования называеться являеться, т.е. производный класс есть разновидностью базового класса.
Пример
```cpp
class Base {
  public:
   void print() {
     std::cout << "I'm from base class" << std::endl;
   }
};

class Derived: public Base {
  public:
   void hello() {
     std::cout << "I'm from derived class" << std::endl;
   }
};

int main(int argc, char const *argv[]) {
    Derived d;
    d.hello();
    d.print();
    Base b;
    b.print();

    Base& base = d;
    base.print();
    // error: ‘class Base’ has no member named ‘hello’
    // base.hello();
    return 0;
}
```
Как видим из примера через объект класса `Derived` можно получить доступ к методу `print` класса `Base`, при том что мы ее не объявляли в классе `Derived`, она нам пришла в наследство. Ну вызов через объект базового класса `Base` интереса никакого не несет, и так понятно что мы не можем вызвать методы производного класса так как базовый класс понятия не имеет о производном классе.
Интресеный представляеться ссылка. Мы знаем что ссылка это алиас на то что она ссылаеться. Тут интересный момент в том что мы иммет ссылку на базовый класс можем присваивать объект базового класса. И это очевидно, т.к. производный класс есть разновидностью(под объектом базового класса). Но почему так происходит? Как мы можем такое делать? Ведь если мы попытаемся например присвоить объекты разных типов, то мы получим ошибку несовместимости типов? Но это частично одинаковые типы, почему так дам маленький пример. Ответ кроеться в том как объект производного класса размещаеться в памяти
```cpp
class A {
  int a;  
};

class B: public A {
  int c;  
};

int main(int argc, char const *argv[]) {
  std::cout << sizeof(B) << " " << sizeof(A) << std::endl;
}
```
Если запустить эту программу то на экране мы получим 8 и 4. Т.е. объект производного класса содержит объект базового класса плюс свои поля поля.

```
****Derived*Memory***
* Base::a : c       *
*********************
```
И теперь становиться понятно почему мы базовому классу можем присвоить объект производного класа. Просто компилятор берет вначале памяти данные для объекта базового класса. Мы с вами расматривали каламбур типов(union).
Но если мы попытаемся через ссылку базового класса обратиться к методам производного класса даже имея ссылку на производный, то мы видим что по памяти он просто ссылаеться на свой базовый подобъект в производном классе, и у него нет метода hello.
Это еще называеться статическое связваение, т.е. вызовы даже через ссылку или указатель на производный класс, могут вызвать методы только базового класа.
**Закрытое наследование** Говорят что оно означаеть "реализован посредством"(или другим словом наследование реализации), суть которого что все `public` и `protected` элементы базового класса, будут доступны как `private`. Т.е. в отличии от открытого где вы могли через объект наследника вызвать публичный метод из базового класаа. То теперь вы должны писать некие методы обвертки, для доступа из вне. Идея такого наследования, есть пример адаптеров, т.е. если у нас есть какой либо функционал и мы хотим его ограничить, т.е. изменить поведение в производном классе, то мы пишем некие овертки над этими методами. Примером например может быть класс стек, он может унаследоваться от класса вектор, но так как стеку нужны только операции `push`, `pop`, `top` то он наследуется закрыто от класса vector, и реализует эти методы через методы класса вектор, предоставив пользователю ограниченный интерфейс.
Пример
```cpp
class Derived: public Base {
  public:
   void hello() {
     std::cout << "I'm from derived class" << std::endl;
   }
};

class DerivedPrivate: private Base {
  public:
   void hello() {
     std::cout << "I'm from derived class" << std::endl;
   }
   void wrapper_print() {
     std::cout << "I'm call method print base class via wrapper" << std::endl;
     print();
   }
};

int main(int argc, char const *argv[]) {
    DerivedPrivate dp;
    dp.hello();
    // dp.print();
    dp.wrapper_print();

    /*
     Base& base_private = dp;
     base.print();
    */
    return 0;
}
```
Как видно из примера выше мы теперь неможем вызвать публичный метод `print` базового класса через объект производного класса, так как он наследуеться закрыто, вместо этого мы пишем обвертку метод `wrapper_print` которая вызывает метод `print` базового класса. Но и это еще если попытаться создать ссылку или преобразовать объект производного класса в баззовый, то мы получим ошибку `error: ‘Base’ is an inaccessible base of ‘DerivedPrivate’`. Проблема в том что открытым наследованием мы наследовались по принциыпу являеться, т.е. то что верно для базового класса также и верно и для производного класса. Но при закрытом наследовании мы этого не можем сделать, так как подоъект базового класса есть закрытый.
**Закрытое наследование еще можно реализовать понятием композиции**
**Защищенное наследование** т.е. наследование protected. Я до сих пор не могу понять зачем оно вообще нужно. Смысл его такой же как и закрытого только вместо того что элементы становяться `private` они становятся соответсвенно `protected`. Идея его в том чтобы продлить наследование до производных классов от нашего производного класса.

Ок, вернемся к нашему классу разобравшись что такое спецификатор доступа. Интересным есть следующая конструкция в конструкторе Student
```cpp
  Student(unsigned id, unsigned age, unsigned group)
   : People(id, age), group(group) {

  }
``` 

Т.е. пользовательский конструктор класса Student должен вызывать пользовательский конструктор базового класса People, и не только вызвать а еще принимать параметры для инициализации приватных полей класса базового класса. Ну это становиться понятно, т.к. производный класс состоит как из базового(его полей), так и своих, но мы знаем что производный класс не имеет доступа к полям базового класса, поэтому он и делигирует вызовы конструктору базового класса.
Вопрос так все происходит для всех конструкторов и операторов присвания, т.е. надо явно вызвать конструкторы бозового класса. Ответ нет, единственное что надо вызвать так это в пользовательском конструкторе, т.к. начальное поведение полей может измениться, но если в базовом классе есть конструктор по умолчанию, то его можно не указывать в списке инициализации пользовательського класса, тем самым поля базового класса инициализируються дефолтными значениями. Другой момент почему мы не можем вызвать поля напрямую, **это то что базовый класс нашего производного класса сам может быть производным**. В примере с классами Derived и Base мы не вызывали не одного явно конструктора, за нас это делает компилтор в конструкторе по умолчанию. Теперь понятно почему необходимо использовать для выделения памяти оператор new вместо С функции malloc, это то что оператор вызвает конструктор котырый правильно конструирует объетк выделя для него память и вызывая конструкторы базовых классов.
Вообщем порядок инициализации при следующем создании объекта
```cpp
Student student(100, 21, 10);
```

1. В списке инициализации вызываеться конструктор базового класса.
2. В списке инициализации базового класса, если он есть производным вызываеться конструктора базовых классов.
3. Выполняеться тело конструктора базового класса. Т.е. мы полноценно создали объект базового класса.
4. Потом инициализируються поля базового класса, в том порядке в котором они объялены в секции `private`, а не в порядке списка инициализации.
5. Потом инициализируються поля производного класса в том порядке в котором они объевлены, а не в порядке списка инициализации.
6. Потом выполняеться тело производного класса, т.е. создаеться обеъкт производного класса. В итоге память будет выделена под объект базового класса и под объект производного класса.

Я думаю с этим делом все ясно.
Последним моментом котым я хотел расмотреть есть скрытие методов.
```cpp
  void print() {
    People::print();
    std::cout << group << std::endl;
  }
```

Как видно и класс People содержит метод `print` и класс Student содержит метод `print`. Этим производный класс скрывает методы с таким же именем. Важно то что скрывает все методы базового класса, не зависимо от типов и количества параметров. Для того чтобы вызвать метод базовго класса есть два пути это надо явно указать через область видимости базовго класса имя метода. Как в примере с методом `print` производного класса мы вызываем метод базового класса следующим образом `People::print();` в теле метода производного класса. Т.е. таким способом мы рассширем область видимости, если мы уберем `People::`, то мы получим рекурсию. Но если метод базового класса публичный, то можно и так вызвать, но я так не люблю.
```cpp
    Student student(100, 21, 10);
    student.print();
    student.People::print();
```  

Т.е. расширять область видимости можно и при вызове метода. Т.е. указав где искать)
Давайте намутим пример доказывающий что скрываеться все.
```cpp
class BaseShadow {
 public:
  void calc(int i) {
    std::cout << __PRETTY_FUNCTION__ << std::endl; 
  }
  void calc(double i) {
    std::cout << __PRETTY_FUNCTION__ << std::endl; 
  } 

  void calc(double d, int i) {
    std::cout << __PRETTY_FUNCTION__ << std::endl; 
  }
};

class DerivedShadow: public BaseShadow {
 public:
  void calc() {
    std::cout << __PRETTY_FUNCTION__ << std::endl; 
  }
};

DerivedShadow d_shadow;
d_shadow.calc();
d_shadow.calc(10);
```
Ок, быстрое описание что у нас есть. А есть у нас базовый класс, в котором определены методы `calc` с разным набором параметров. И есть производный класс, в котором опредено только один метод `calc` который не принимает параметр. Если вызвать первый метод `calc` без параметров, то все будет ок мы вызовем метод производного класса. Ну по логике наследования мы наследуем поведение базового класса, 
**так как производный класс являеться также объектом базового класса(но не наоборот)**. Но тут есть такой момент, это правила поиска метода, все происходит так по типу производного класса компилятор ищем в скопе производного класса имя метода, и он его находит, и компилтор прекращает искать это имя, если бы его небыло он бы начал дальше искать в скопе базового класса, потом в намеспейсе и так до глобал скопа. Т.е. компилятор находит имя в производном классе, и прекращает поиск даже если он имеет неправильные типы параметров. А как добавить в скоп производного класса все методы базовго класса. Это делаеться следующим образом.
```cpp
class DerivedShadow: public BaseShadow {
 public:
  using BaseShadow::calc;

  void calc() {
    std::cout << __PRETTY_FUNCTION__ << std::endl; 
  }
};

DerivedShadow d_shadow;
d_shadow.calc();
d_shadow.calc(10);
```
Следующей строкой  `using BaseShadow::calc;` мы внесли в область видимости производного класса все методы `calc`, который перекрывал производный класс.
Ну еще я бы хотел упомянуть порядок вызовов деструкторов, как создаються объекты мы уже увидели, а вот в каком порядке они разрушаються. А разрушаються они в обратном порядке создания.
1. Вызываеться деструктор производного класса.
2. Вызываються деструкторы полей производного класса.
3. Вызываеться деструктор базового класса.
```cpp
class One {
 public:
  One() {
    std::cout << "ctr One" << std::endl; 
  }

  ~One() {
    std::cout << "dtr One" << std::endl; 
  }
};

class Two {
 public:
  Two() {
    std::cout << "ctr Two" << std::endl; 
  }

  ~Two() {
    std::cout << "dtr Two" << std::endl; 
  }
};

class Three: public One {
 public:
  Three() {
    std::cout << "ctr Three" << std::endl; 
  }

  ~Three() {
    std::cout << "dtr Three" << std::endl; 
  }
 private:
  Two tw;
};

Three three;
```

Вывод на экран
```
ctr One
ctr Two
ctr Three
dtr Three
dtr Two
dtr One
```

## Множественное наследование в С++
В отличие от многих языков программирование в С++ есть множественное наследование. Если при одиночном наследовании мы наследовали свойтсва(характеристики) и поведение от одного базового класса, то при множественном мы наследуем это одно нескольких классов. Т.е. просизводный класс может содержать более чем один базовый класс. Иногда говорят что множественное наследование это источникбольших неоднозначностей и проблем, но мое мнение если его правильно применять и правильно спроектировать производный класс, то проблем никаких не будет. Хороший пример множественого наследование есть класс `XYZ`.
Пример
```cpp
#include <iostream>

class X {
 public:
  void addXProperty() {
    std::cout << "Add X property" << std::endl;
  }
};

class Y {
 public:
  void addYProperty() {
    std::cout << "Add Y property" << std::endl;
  }
};

class XYZ: private X, private Y {
 public:
  void addXYZProperty() {
    addXProperty();
    addYProperty();
    std::cout << "Add Z property" << std::endl;
  }
};

int main(int argc, char const *argv[]) {
    XYZ xyz;
    xyz.addXYZProperty();
    return 0;
}

``` 
Вывод
```
Add X property
Add Y property
Add Y property
```
Это классический пример как класс наследник получает свойства от двух классов. Пример такого класса есть класс например Button кнопка, т.е. она наследует свойства окна, и наследует свойства например рамки.

Вызов конструктора такой же как и при одиночном наследовании, только порядок вызова будет идти в том порядке в котором указано в списке наследования. В нашем примере это будет вызов конструктора `X`, потом конструктор класса `Y`, ну а потом уже конструктор класса `Z`.
В памяти представлены множественное наследование точно также как и при одиночном просто теперь производный класс будет содержать несколько объекьтов баззвых классов.
На этом можно было поставить точку, но не получиться, есть проблемы при множественном наследовании.
1. Неодноначность вызова имени базового класса.
Пример
```cpp
class A {
 public:
  void print() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;   
  }
};

class B {
 public:
  void print() {
    std::cout << __PRETTY_FUNCTION__ << std::endl;
  }
};

class C : public A, public B {};

int main(int argc, char const *argv[]) {
  C c;
  c.print();
  return 0;
}
```
В примере выше класс `C` унаследовал по двум путям класса `A` и класса `B` имя `print`. И как показано в примере если мы попытаемся вызвать метод `print` через объект производного класса, то мы получим сообщение об ошибке от компилятора, так как он не знает какой метод `print` базового класса вызвать, будет ли это `A::print` или `B::print`. Решить эту проблему можно переопределив метод в производном классе и внем указать через расширения области видимости  метод какого базового класса надо вызвать.
Или при вызове метода указать через раширения области видимости метод какого базового класса надо вызвать.
```cpp
  c.A::print();
```

2. Проблема ромбового наследования. Сразу пример.
```cpp
/*Diamond problem*/

class Base {
public:
 /*...*/
protected:
  int data_;
};
class Der1 : public Base { /*...*/ };
class Der2 : public Base { /*...*/ };
class Join : public Der1, public Der2 {
public:
  void method()
  {
     data_ = 1;
  }
};
/*********InMemory*****************/
/*     *************              */
/*     *  Base     *              */
/*     *  Der1     *              */
/*     *************              */
/*                                */
/*     *************              */
/*     *  Base     *              */
/*     *  Der2     *              */
/*     *************              */
/*                                */
/*          Join                  */
/**********************************/
int main(int argc, char const *argv[]) {
    Join* join = new Join();
    Base* base = join;
    return 0;
}
```
Как видно с рисунка(не очень получился), то мы в производном классе `Join` унаследовали две копии объекта класса Base через класс `Der1` и класс `Der2`. Если запустить этот пример то получим ошибку следующего типа
```
multi_inheritance.cpp: In member function ‘void Join::method()’:
multi_inheritance.cpp:57:6: error: reference to ‘data_’ is ambiguous
      data_ = 1;
      ^~~~~
multi_inheritance.cpp:49:7: note: candidates are: int Base::data_
   int data_;
       ^~~~~
multi_inheritance.cpp:49:7: note:                 int Base::data_
```
Т.е. компилятор не может понять через какой из подобъектов базового класса обратиться к полю data_. Т.е. обратиться через класс `Der1::Base::data_` или `Der2::Base::data_`. Даже расширение области видимости не поможет.
И вдругой строчке кода мы не сможем получить указатель на подобъект базового класса, так как неоднозначность какого класса.
Т.е. получаем следующую картину
```
/*
    *******     ******
    *Base *     *Base*
    *******     ******
       *          *
    *******     ******
    *Der1 *     *Der2*
    *******     ******
       *         *
        *       *
          *******
          *Join *
          *******
*/
```

А нам надо следующего вида
```
/*
          ******
          *Base*
          ******
          *   *
         *     *     
    *******     ******
    *Der1 *     *Der2*
    *******     ******
       *         *
        *       *
          *******
          *Join *
          *******
*/
```
Т.е. нам нужен механизм который бы создавал только один объект базового класса. И это механизм называеться вирутальное наследование.
Решение нашей проблемы следующеее
```cpp
class Base {
public:
 /*...*/
protected:
  int data_;
};
class Der1 : public virtual Base { /*...*/ };
class Der2 : public virtual Base { /*...*/ };
class Join : public Der1, public Der2 {
public:
  void method()
  {
     data_ = 1;
  }
};
```
Как видно из примера мы в каждом базовых классах `Der1` и `Der2` класса `Join`, объявили что мы наследуемся от базового класса виртуально. На сами классы `Der1` и `Der2` если их использовать по отдельности никакого влияние не будет они будут содержать каждый по отдельной копии базового класса `Base`, а вот если они выступают как базовые и их может быть несколько как `Der1` и `Der2`, то компилятор с помощью ключевого слова выполняет создание одного только объекта базового класса `Base`.
Вопрос кто ответсвенный за создание базового класса, если он не вызываеться не в `Der1` и не в `Der2`. А за это отвечает как раз и производный класс, т.е. он ответсвенный за вызов самого базового класса. У нас это происходит неявно, т.к. это нормальное поведение для дефолтного конструктора, но если бы у нас в базовом классе был только пользовательський конструктор, то нам бы пришлоссь явно вызвать этот конструтор из производного класса `Join`. Виртуальное наследование ничего общего не имеет с виртуальными методами.
Возможное размещение в памяти виртуального наследования
```cpp
/*
    ********
    * Der1 * ********
    ********        *
                    *
    ********        *
    * Der1 * *****  *
    ********     *  *
                 *  *
      Join       *  *
                 *  *
    ********     *  *
    * Base *  *******
    ********
*/
```

Возможно будет выделенна память под базовый класс, и в классах `Der1` и `Der2` может храниться указатель на этот объект базового класса. А может и подругом 