# Работа с файлами
Работа с файлами есть важной частью, работы программы. Например в Linux все являеться файлами. Программы например хранят в файлах свои настройки, или например файлами обмениваються настройками между приложениями. Но также и хранения ключей, для шифрования.
Различают работу с файлами двух типов, это текствый файл и двоичный файл. Как было сказано конфигурация приложения в большей степени хранится в текстовом формате, тогда как приватный ключ храниться в бинарном виде, или картинка есть бинарное представление.
В С++ поддерживаеться два подхода работы с файлом. Это работа в стиле С, и вторая это работа с файлом в ввиде ООП подхода, т.е. работа как с объектом.
В данном разделе мы расмотрим работу в стиле С, но когда мы начнем рассматривать классы и объекты мы вернемся к работе с файлом.
Ок, так как происходит работа с файлом. Это потоковый обмен байтами между вашим приложение и вашей программой. Т.е. мы или читаем с потока или записываем в поток. Мы уже работали с файлами когда выводили что то на экран или что то считывали с клавиатуры. Файл в программе называют дескриптором. Т.е. грубо говоря это данные, которые однозначно идентифицируют объект. Но на самом деле с каждым файлом связан дескриптор, это не отрицательное число, которое ядро возращает процессу запросившое это ресурс. Т.е. доступ к нему невозможен если им владеет уже один процесс.
Как было сказано в системе есть уже открытые потоки ввода-вывода, и они имеют индетификаторы 0 - являеться входным потоком `stdin`, 1 - связано с потоком вывода `stdout`, и есть 3 - это поток диагностики, или говорят потоком ошибки `stderr`.
Они открываються когда загружаеться наша ОС, и их не надо повторно открывать.
Также файлы используються при работе в межпроцессорном и сетевом взаимодействии(самым популярным есть сокет)

Простой пример вывода на экран и считывания с экрана
```cpp
#include <cstdio>

constexpr unsigned SIZE_BUF = 100;
int main(int argc, char const *argv[]) {
  fprintf(stdout, "Output into stdout\n"); // это равносильно printf
  fprintf(stderr, "Output into stderr\n");
  char buff[100];
  fgets(buff, SIZE_BUF, stdin);
  fprintf(stdout, "You are enter: %d %s\n", stdin, buff);
  return 0;
}
```

Как видно со стандартными потоками связаны, дескрипторы которые уже открыты.

Хочу сказать что это будет быстрый экскурс по работе с файлами, с более детальной инфрормацией можете ознакомиться уже с официальной документацией.

## Работа с текстовым файлом
Текстовый файл содержит ASCII или Unicode символы. Т.е. это те символы которые мы можем прочитать.
Давайте сразу пример, простого вывода информации о человеке
```cpp
#include <cstdio>
#include <unistd.h>

struct People {
  const char* str;
  unsigned age;
};

bool isFileExists(const char *file_name) {
  return access(file_name, F_OK) == 0;
}

void printFile(FILE* pFile) {
  if (pFile != nullptr) {
    fseek(pFile, 0, SEEK_SET);    
    char buff[100];
    while(fgets(buff, 100, pFile)) {
      printf("%s", buff);
    }
  }
}

int main(int argc, char const *argv[]) {
  const char* mode = "w+";
  constexpr const char* file_name = "people_config.txt";
  bool is_file_exist;
  if ((is_file_exist = isFileExists(file_name))) {
    mode = "r+a";
  }

  FILE *pFile = fopen(file_name, mode);
  if (pFile != nullptr) {
    People people{"Ivanov Ivan", 25};
    if (is_file_exist) {
      fseek(pFile, 0, SEEK_END);
    }
    fprintf(pFile, "%s\n%u\n", people.str, people.age);
    printFile(pFile);
    fclose(pFile);
  } else {
    fprintf(stderr, "Can't open file\n");
  }

  return 0;
}
```
Как видно с примера файл представляет собой указатель на структуру `FILE`, это очень сложная структура. Файл работает в рижиме чтения, режиме записи, в режиме дозаписи. Если файл открыт в режиме записи, с модификатором `w`, то файл будет создан на диске. Режим дозаписи это просто дописываение данных в конец файла. Но если мы открыли файл, то чтобы нам начать писать в конец файла, на для этого надо установить курсор в конец файла используя функцию `seek`. Стоит обратить внимание что при чтении или записи в файле есть так называемый курсок текущего положения, т.е. он указывает что сейчас будет прочтено с файла. В файле есть такое понятие это конец файла `EOF`, это такой битовый флаг что курсор файла находится в конце файла.

## Работа с бинарными данними.
Вот что интересно это работа с бинарными данными. Сразу скажу что бинарные данные лучше читать целиком, а не размерности как это было с текстовым файлом. По умолчанию работа с файлами происходит в текстовом режиме.
Ок сразу пример. Мы будем читать и записывать структуру в файл.
```cpp
#include <cstdio>
#include <unistd.h>
#include <cstdlib>

struct People {
  unsigned age;
  const char fio[100];
};

bool isFileExists(const char* file_name) {
  return access(file_name, F_OK) == 0;
}

void ReadFromFile(const char* file_name) {
  if (file_name!= nullptr &&
      *file_name          &&
      isFileExists(file_name)) {
    auto pfile = fopen("binary_file.people", "rb");
    if (pfile != nullptr) {
      People people{};
      fread(&people, sizeof(People), 1, pfile);
      printf("people %s %d\n", people.fio, people.age);
      fclose(pfile);
    } else {
      printf("File can't open");
    }
  } else {
    printf("File not exists");
  } 
}

void WriteToFile(const char* file_name) {
  if (file_name!= nullptr &&
      *file_name) {
    auto pfile = fopen("binary_file.people", "wb");
    if (pfile != nullptr) { 
      People people{25, "Ivanov Ivan"};

      fwrite(&people, sizeof(People), 1, pfile);
      fclose(pfile);
    }
  } 
}

int main(int argc, char const *argv[]) {
  constexpr const char* file = "binary_file.people";
  ReadFromFile(file);
  WriteToFile(file);
  return 0;
}

```
Как видно из примера выше работа с бинарными данными присходит блоком, а не по полю например структуры, т.е. записываться весь блок памяти этой структуры. Точно также и вычитываеться.
И для работы с бинарными данными используют функции `fread` и `fwrite`.
