# Основные операции С++
После рассмотрения переменных и их типов, мы знаем что они служат как индетификатор для ссылки на область памяти для того чтобы сосчитать значение с памяти или записать(в случае если переменная не константная). Ну все это классно, но язык только выполняя такие опреции был бы не полон, т.е. необходимы некий механизмы для малинипуляции(обработки) этих данных(переменных). Для этого в языке С++ есть огромный набор операций для работы с данными. Их называют операторы и они обозначаються разными специальными символами(+, -, / и т.д.). С помощью опреаторов мы можем выполнять математические опреации, логические, битовые. Оператор он оперирует операндами(переменные, литералы).
Различают следующие виды операторов:
- Унарный
- Бинарный
- Тернарный(будем рассматривать в разделе условные операторы)
Бинарный опреатор, работает с двумя операндами, и  имеет следующий вид 

```cpp
операнд оператор операнд;
```

Унарный оператор может стоять как перед операндом, так и после

```cpp
операнд оператор;
оператор операнд;
```

Хотел бы уточнить важную деталь, некоторые операторы могут нести другой смысл в зависимости от контекста. Например оператор +(сложение), для встроенных типов имеет один и тот же смысл сложение двух чисел(даже и с типом char, хотя результом будет иногда другой символ), но если применить к строкам (класс std::string, прошу прощение что забежал вперед), то он означает сложение двух строк. Это все происходит из-за возможности перегрузки операторов в С++. Но и для не перегруженных есть другой смысл, например оператор &, если его использовать как бинарный оператор то он применяеться для бинарной арифметики, а если его использовать как унарный оператор то он рассматриваеться как оператор взятия адресса.
## Оператор присвоение
Мы с Вами уже рассматривали оператор присвоение, когда рассматривали типы данных. Но сейчас рассмотрим его подробней.
Простыми словами оператор присвоение это присвоение значение переменной. Оператор присвоение имеет следующий вид:
```cpp
// операнд = операнд
```
Как видим с описания оператор присвоение это бинарный оператор. Левый операнд оператора присвоения являеться переменной, а правая часть должна быть значением. Под переменной понимаем участок памяти куда можно что то записать, под правой частью понимаем значение, при этом значением может быть как переменная(считать данные лежащие в этой переменной), так и литерал.
Примеры
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
  // обьявляем переменную(переманная неявно инициализируеться неопределенным значением)
  unsigned value;
  // присваеваем переменной value значение 30
  value = 30;
  printf("value = %d\n", value);

  /*
    другой пример использования оператора присвоения это использовать его при инициализации переменой,
    т.е. совместить обьявление с инициализацией
  */ 
  unsigned value2 = 40;
  printf("value2 = %d\n", value2);

  // присвоение, но в качестве значения есть не литерал, а значение переменной, в этом случае старое значение переменной затреться
  value = value2;
  printf("value = %d\n", value);
  
  /*
    результат операции присвоение может быть также значением
    в примере ниже все три переменные будут иметь одно и тоже знеачение, т.е.
    переменная value3 проинициализируеться значением результата присвоение перменной value2 значения переменой value
    В этом примере стоит заметить что присвоение всегда выполняеться справа на лево
  */
  unsigned int value3 = value2 = value; // тоже самое unsigned int value3 = (value2 = value);
  printf("value3 = %d value2 = %d value = %d\n", value3, value2, value);
  printf("value = %d\n", value = (value3 + 40));

  unsigned char value4 = 90;
  // неявное преобразование типа char > unsigned int
  value3 = value4;
  // ошибка так как невозможно преобразовать типы ‘const char*’ to ‘unsigned int’
  // value3 = "Hello World";
  /*
   при попытке выполнить следующий оператор присвоения, мы также получим ошибку компиляции, получим ошибку что
   "lvalue required as left operand of assignment" в левой части оператора присвоения должно стоять lvalue
  */ 
  // 6 = value3;
  // 5 = 10;

  return 0;
}
```
С примера выше видно, что оператор присвоение может быть значением для другого опреатора присвоение, т.е. можна выстраивать цепочки присвоения. Опреатор присвоение есть строгий порядок выполнения, т.е. справа на лево, и это даже видно из цепочки присвоения(но и это и очевидно, нам надо что то взять, в данном случае значения что бы потом его положить в переменную)
Оператор присвоение считаеться коректным если ему присваеться значение соответсвующего типа или значение которое неявно можно приобразовать к присваемому типу.
Если попробовать расскоментировать последние строки кода, то мы увидем странное сообщение компилятора в котором говорится о каком то lvalue. Это связано с тем что каждое выражение имеет тип и принадлежит так называемой числовой категории(value category). Числовая категория это базовые правила, в соответствии компилятор должен следовать, когда он создает, копирует, или перемещает временные обьекты на протяжении вычесления выражения.

### Rvalue и Lvalue
Я постараюсь их рассмотреть очень простыми словами
До C++11 го было только два понятия Rvalue и Lvalue, и все жили спокойно, но с приходом нового стандарта и появление move семантики(прошу за сполер и может пока неизвествные названия) пришлось довалять/расширять к другим понятием числовым категориям.
 ![](value_categories.png)
https://en.cppreference.com/w/cpp/language/value_category

Эти определения очень сложны, мы к ним вернемся когда будем рассматривать ссылки
Если просто то lvalue это может быть обьект, в нашем случае или функция, т.е. lvalue характеризуеться как выражение чей адресс мы можем взять(с переменной связана область памяти, функции мы рассмотрим позже но они тоже храняться в памяти).
Rvalue это выражение в котром нельзя взять его адресс(например адресс литрала 45, мы взять не может т.к. он не храниться в памяти). Т.е. это не объект и не функция. Примеры rvalue это литерал(это не объект), возвращаемое значение функции, результат вычисления выражения.
После немногого прояснения понятно почему компилятор ругался, т.к. мы пытались литералу присвоить значение, но память на литерал нигде не выделялась. Ну сами посудите какой в этом смысл 5 = 10.
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
    // переменная а есть lvalue т.к. с ней связан адресс в памяти, литерал 30 это rvalue
    int a = 30;

    /* 
     в данном случае переменная а и b есть lvalue,
     но с переменной b считыветься значение которое являеться временным и автоматически есть rvalue
    */
    int b = a;

    // ошибка, т.к. и не логично
    // 7 = b;

    // но строковый литерал есть lvalue, т.к. он находиться в read only памяти
    printf(R"(Address literal "Hello World" is %p)", &"Hello world");
    // ошибка компиляции т.к. нельзя взять адресс целочисленого литерала lvalue required as unary ‘&’ operand
    // printf("Address literal 7 is %p", &7);

    return 0;
}
```
Вопрос на самостоятельное понимание, почему строковый литерал это lvalue?

Но возникает новое понятие временная переменная. Ну давайте и это понятие разберем
### Временная переменная
В соответсвии с википедией, мне юольше всего понравилось его определение. Вре́менные объекты(переменные) — в C++ объекты(переменные), которые компилятор создаёт автоматически по ходу вычисления выражений. Такие объекты не имеют имени и уничтожаются сразу же, как только в них исчезает потребность.
Мы будем часто сталкиваться с понятием временных переменных. Мы уже получали временные переменные, когда мы писали функцию `printf` согласно документации она возвращает результат количества напечатаных символов, или отрицательное число в случае ошибки. Из этого следут что мы получаем временное значение котрое живет до окончание инструкции, т.е. до `;`.
Иногда при компиляции кода с определенным флагом, который требует обрабатывать возращаемое значение, компилятор выдает ошибку/ворнинги что игнориться возвращаемое значение.
Вторым примером временного объекта, являеться приведение типа.
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {

    // сохраняем временную переменную возращаемую функцией printf
    int count_read_symbol = printf("Hello world");
    // способ подавить ворнинги компилятора, если мы не обрабатываем возращаемое значение
    (void) printf("count %d", count_read_symbol);

    float float_value = 1.45;
    // преобразование типов также приводит к созданию временного объекта
    int int_value = static_cast<int>(float_value);

    (void) printf("int_value %d\n", int_value);

    printf("int_value %p\n", &int_value);
    // результатом оператора присвоение не есть временный объект
    printf("assigned address %p\n", &(int_value = 20));
    return 0;
}

```
### Арифметические операции
Так как мы в начале рассматриваем только встроенные типы, то будем рассматривать только арифметические операции, по их прямому назначению, т.е. в С++ арифметические операции прямо означаю то что и в матиматическом понимании. Дальше мы будем рассматривать указатели так вот некоторые арифметические операции, ведут себя иначе, например операция +, которая перемещает указатель на количество байт. 
Выделяют пять арифметических операций:
+ оператор сложения
- оператор вычитания
* оператор умножения
/ оператор деления
% остаток от целочисленого деления

Оператор +, он бывает как бинарный так и унарный. И имеет следующий вид:
```cpp
операнд + операнд // бинарный

+операнд // бинарный

```
```cpp
#include <cstdio>
#include <cstdint>

int main(int argc, char const *argv[]) {
  // объявляем переменную
  uint16_t value;
  // сложение двух rvalue
  value = 30 + 50;
  printf("value = %d\n", value);

  /*
   совмещение объявления и инициализации с использование оператора +
   тут используеться микс, т.е. в качестве операндов может быть как lvalue + rvalue
   или наоборот rvalue + lvalue
  */
  uint16_t value2 = value + 90;
  printf("value2 = %d\n", value2);

  // используеться как lvalue + lvalue
  uint16_t value3 = value +  value2;
  printf("value3 = %d\n", value3);

  // пример где в качестве операнда может быть значение результата присвоения
  uint16_t value4 = 200 + (value = value3);
  printf("value3 = %d\n", value4);

  // будет ошибка компиляции, попытка rvalue(временной переменной) присвоить значение 
  // (value + 300) = value4;

  /*
   ошибка, так как оператор +, в бинарном виде должен иметь два операнда, т.е. суть в том что компилятор ожидает полное выражение
  */
  // uint16_t value5 = value4 + ;

  // Есть унарный + но смысла я в нем невижу, к сожалению, его идея это добавить знак + к значению, как в матиматике
  // явно указываем что число у нас положительное, применяеться к rvalue
  uint16_t value5 = +10;
  printf("value5 = %d\n", value5);
  
  // явно указываем что число у нас положительное, применяеться к lvalue
  value4 = +value5;
  printf("value4 = %d\n", value4);

  // ошибка, такая как и с бинарный оператором +
  // +value5 = value4;

  // два литерала double
  double value6 = 1.25 + 3.25;
  printf("value6 = %f\n", value6);

  // также можно использовать суфиксы
  value6 = 1.f + 1.30;
  printf("value6 = %f\n", value6);

  // результат будет  вещественное число double > int
  value6 = 1000 + 1.40;
  printf("value6 = %f\n", value6);

  // 170 + 220 = 390, т.е вместо 390, увидем 134, это пример переполнения
  uint8_t value7 = value2 + 220;
  printf("value7 = %d\n", value7);

  // но этого можно избежать используя вывод типов, получим 390
  auto value8 = value2 + 220;
  printf("value8 = %d\n", value8);

  // ну или используя унифицированную инициализацию, получим предупреждения компиляции сужающие преобразование
  uint8_t value9 {value2 + 220};
  printf("value9 = %d\n", value9);

  // но в этом случае мы получим ошибку компиляции narrowing conversion
  // value9 = {255 + 255};

  return 0;

}
```
С примера выше видно, что операндами оператора + может быть как rvalue так и lvalue. Результат оператора + это всегда rvalue, если раскоментировать некоторый код с примера, то мы увидем ошибку компиляции, то что мы пытаемся записать значение в rvalue, что не соответсвеет правилам компиляции. Унарный оператор + может применяться как rvalue, так и к lvalue.
Какие могут быть проблемы связанные с оператором +? самой большой может быть, это когда значение выражение в правой части больше по типу чем переменная в левой части.
Таакже важно понимать что при выполнении арифметической операции, результат вычесления выражение продвигаеться в сторону большего типа, например поумолчанию все литералы имееют тип int, и если сумма двох литералов больше типа int он продвигаеться к типу большего размера(например если на некоторой системе тип int 32, то продвигаеться к 64). И также если переменная в качестве операнда иммеет больше тип чем другой операнд(rvalue, lvalue), то результат продвигаеться к типу переменной большего размера.
Оператор +, так же само справедлив и для вещественной арифметики, так же само справедливо и продвижение типа. Также необходимо не забывать о срезке.
Для избежания, возможных срезок или сужающих преобразований (narrowing conversion), применяйте ключевое слово auto, или универсальный способ инициализации/присвоения.
Но огромное но, универсальная инициализация, ошибку компиляции, только если сможет вычеслить результат выражения во время компиляции

Оператор - также как и оператор + бывает бинарный и унарный.
Оператор +, он бывает как бинарный так и унарный. И имеет следующий вид:
```cpp
операнд - операнд // бинарный

-операнд // бинарный

```
Он по семантике идентичен также как и оператор +, только вычитает одно значение от другого(вообщем как и в математике). Также проблемы присущие опреатору +, в плане переполнения, или срезок, присущи и оператору -
```cpp
void work_with_operator_minus() {
  // разница в том что результатом выражения надо делать знаковую переменную, т.к. результат может быть отрицательное число

  int32_t value1 = 100 - 70;
  printf("value1 = %d\n", value1);

  int32_t value2 = value1 - 70;
  printf("value2 = %d\n", value2);
  uint32_t value3 = 100;
  // иногда логически не коректен т.к. размер безнакового больше чем знакового и мы можем получить переполнения
  int32_t value4 = value3 + value2;
  printf("value4 = %d\n", value4);
  // получим переполнение
  value4 = std::numeric_limits<uint32_t>::max() - 100;
  printf("value4 = %d\n", value4);

  // получим ошибку компиляции
  /*value4 = {std::numeric_limits<uint32_t>::max() - 100};
  printf("value4 = %d\n", value4);*/

  // но если написать так то все скомпилируеться ок, магия
  value4 = {std::numeric_limits<uint32_t>::max() + 100};
  printf("value4 = %d\n", value4);

  /*
    тут мы инвертируем знак, в отличие от унарного +, он имеет смысл
    в смене знака надо быть тоже осторожным, если мы поменяем с бещнакового на знаковое получим переполнение
  */
  int32_t value5 = -value2;
  printf("value5 = %d\n", value5);
  printf("value5 = %d\n", -value5);
}
```
Одно значительно отличие есть в опреаторе -, это применения его как унарного, он инвертирует знак оператора на обратный.

Оператор /, по семантике идентичен также как и в математике. Оператор деление может быть только бинарным, т.е. применяться только к двум операндам.
```cpp
операнд / операнд
```
Проблемы сужения, или срезки присущи так же как и для других арифметических операторов. Но есть одно важное замечание, в отличие от матиматики, в которой деление дает всегда дробное число, то в языке С++ если два операнда есть целочисленными, то и результат будет целочисленным
```cpp
void work_with_divide() {
  // получим целое число без дробной части
  double value1 = 10 / 20;
  std::cout << "value1 = " << value1 << std::endl;
  // получим число с дробной частью
  // или можно использовать явное преобразование к типу
  value1 = 10.f / 20; // value1 = (double)10 / 20;
  std::cout << "value1 = " <<  value1 << std::endl;
  
  int8_t value2 = 100;
  // полученем целое число
  value1 = value2 / 90;
  std::cout << "value1 = " <<  value1 << std::endl;
  value1 = value2 / (double)90; // double(value2) / 90;
  std::cout << "value1 = " << value1 << std::endl;

  // может кинуть исключительную ситуацию
  //int value3 = value2 / 0;
  // получим бесконечность inf
  double value3 = static_cast<double>(value2) / 0;
  std::cout << "value3 = " << value3 << std::endl;

  // это есть не число
  value3 = 0.f / 0;
  std::cout << "value3 = " << value3 << std::endl;
}
```
С оператором деления есть два момента:
Вообще деление на ноль по стандарту это неопределенное поведение, т.е. компилятор вправе сам решать что ему делать в этой ситуации
1. При делении на ноль с целочисленными значениеями, то большинство компиляторов кидают exception деление на ноль.
2. При делении вещественных чисел, взможен другой исход
  - число на ноль, это бесконечность, специальное число inf. Согласно википедии бесконечность это более близкое/правильноее      
    приближение к числу. Получить бесконечность можно при переполнении и при делении ненулевого числа на ноль.
  - не число, nan, если во время их выполнения вычисления произошла ошибка.
https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB

По ссылке выше есть описание что такое не число, и что такое бесконечность. При некоторых алгоритмах, когда нужно какое то начальное значение часто испольуют бесконечность, например для поиска кратчайшего пути в графе
https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B

Оператор *, по семантике идентичен также как и в математике. Оператор деление может быть только бинарным, т.е. применяться только к двум операндам.
```cpp
операнд * операнд
```
Проблемы сужения, или срезки присущи так же как и для других арифметических операторов. В нем отсутсвуют проблемы присущие оператору деления, например двух целых чисел, правила продвижения типов такие же как и оператора + и оператора -
```cpp
void work_with_multiplication() {
  // при умножении можно больше получить возможности переполнения
  int32_t value1 = 100 * 2;
  printf("value1 = %d\n", value1);

  int32_t value2 = value1 * 30;
  printf("value2 = %d\n", value2);

  // получим переполнение, компилятор предупредит, т.к. время компиляции выражение
  uint8_t value3 = 20 * 140;
  printf("value3 = %d\n", value3);

  // тут компилятор не предупредит
  value3 = value1 * 140;
  printf("value3 = %d\n", value3);
  
  // а в этом компилятор пердупредит
  value3 = {value1 * 140};
  printf("value3 = %d\n", value3);
}
```
### Смешанные выражения
После изучение всех, почти всех, арифметических операций, их можно смешивать в одно выражение. Было бы глупо выполнять все эти операции последовательно.
Проблемы срезки, переполнеия также присущи как и для одиночных операций. Правила продвижения типа также присутствуют.
Но перед тем как приступить к примерам со смешанными выражениями, я хотел бы описать в двух словах что такое приоритет операции. 
Как и в математике, в программировании присущи приоритеты, например сначало выполняеться умножение а потом сложение, это понятно. Но как быть например если в одном выражении есть и умножить и разделить. Например:
```cpp
void mixed_expression() {
  // тут понятно, как и в матиматике сначало умножение а потом результат складываться с числом 20
  uint32_t value1 = 20 + 30 * 50;
  printf("value1 = %d\n", value1);
  // все зависит от того как компилятор будет выполнять выражение слева направо или справа на лево
  double value2 = 20.f  / 30 + 25 * 10;
  printf("value2 = %f\n", value2);

  /*
   тут будет неопределенная последовательность вычесления
   т.е. что выполнятися сначало value2 * value2 или value2 / value1 или value1 / value1
   если посмотреть асемблерный код под х86-64 gcc 8.2, то порядок будет
   слева на право
  */
  double value3 = value2 * value2 / value1 / value1;
  printf("value3 = %f\n", value3);
  /*
   чтобы не было такой путаницы применяют оператор (), т.е им мы укащываем что должно быть первым выполняться
   сначало поделим value1 на value1, потом помножим value2 на value2 и потом результат двох выражений поделим между собой
  */
  value3 = (value2 * value2) / (value1 / value1);
  printf("value3 = %f\n", value3);

  uint32_t value_tmp = 100;
  // результат будет отрицательным числом
  auto value4 = value1 * 30 * -value_tmp;
  printf("value4 = %d\n", value4);
}
```
Как видим из примера в некоторых выражения используеться приоритет опрерации
https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D0%B2_C_%D0%B8_C%2B%2B
Т.е. в зависимости от приоритета компилятор выполнит, ио дейсвие которое приоритетное, например в примере выше  переменная `value1`, сначало выполнилось умножение, а потом сложение, т.к. оператор умножение выше в приоритетности чем оператор сложение. Иногда если приоритетность операторов равна, как в примере вначале с переменой `value3`, то компилятор вправе сам поступать что вычеслять первым. Ну для того что бы избавиться от непределенности, используют как и в матиматике оператор круглые скобочки, для того чтобы выделить приоритетность оператора как для в примере для переменной `value3`.
### Составной оператор присвоение
В С++ есть так называемые составные операторы, суть которых следующая: до этого мы просто брали вычесляли выражение и клали его в правую часть, т.е. в lvalue. А если нам например необходмо результат выражения сложить или умножить или разделить с присваемой переменой(типичным примером есть сумма элементов последовательности). И для этого применяеться составные операторы. Правила срезки или переполнения также присущи составным операторам.
Синтаксис составного оператора, имеет следующий вид
```cpp
lvalue += rvalue
lvalue -= rvalue
lvalue /= rvalue
lvalue *= rvalue
```
Т.е. идея составного оператора, очень проста, вычеслить выражение находящее с права, дальше выполнить операцию, например сложение, с переменой находящеся справа, и результат записать в переменную. Ну формально он сразу ее запишет в переменную
Составной оператор это сокращенная форма вида
```
x += 10;
x = x + 10;
// и тоже самое для других

// раскроеться так x = x * (20 + 30);
x *= 2 + 30;
``` 

```cpp
#include <cstdio>
#include <cstdint>

int main(int argc, char const *argv[])
{
    uint64_t value = 0;
    printf("value = %ld\n", value);
    // составной оператор это сокращенная форма value = value + 3;
    value += 3;
    printf("value = %ld\n", value);
    value += 5;
    printf("value = %ld\n", value);
    value += 2;
    printf("value = %ld\n", value);

    // имеет вид value = value * (1 + 2); результат будет на экране 30
    value *= 1 + 2;
    printf("value = %ld\n", value);

    value /= 3;
    printf("value = %ld\n", value);

    value -= 5;
    printf("value = %ld\n", value);
    return 0;
}
```
Составной оператор вида `x += 3` и `x = x + 3` компилятором генерируют одну и туже инструкцию. В коде это просто удобная форма записи, но компилятором это одно и таже инструкция, это надо понимать.
### Инкремент и декремент
Инкримент и декремент есть унарная операция. Простыми словами это увеличение или уменьшение на единицу lvalue. Это сокращенная форма записи следующего кода
```cpp
x = x + 1
x += 1;
++x
```
Компилятор в наше время сейчас для трех приведеных выше операций один и тот же код.
Инкримент и декримент бывают суфиксные(пост) и префиксные. Суть их одна и таже, увеличить/уменьшить переменную на единицу, но если использовать эту инструкцию в выражении, то результат будет немного другой.

```
// пре инкримент
++x;
// пост инкримент(суфиксный)
x++;
// пре декремент
--x;
// пост декремент(суфиксный)
x--;
```
Обе формы как декремента так и инкримента должны быть применены только к lvalue.
Смысл пре и пост следующий:
- Пре операция увеличивает непосредственно переменную на единицу и возвращает сразу результат
```cpp
++x;
x = x + 1;

--x;
x = x - 1;
```
- Пост операция, сначало мы читаем значение с переменной ложим его во пременную переменную, и потом увеличиваем переменную на 1, а в выражении будет использоваться старое значение переменной
```cpp
y = 10 + x++;

tmp = x;
x = x + 1;
y = 10 + tmp;
```
Т.е. видим что при пост операции есть дополнительная переменная, т.е она возвращает rvalue, в то время как пре возвращает lvalue
```
++++x
// так будет ошибка компиляции, так как вы пытаетесь к rvalue применить операцию инкримента
x++++
```
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
  size_t value = 0;
  printf("x = %zu\n", value);
  ++value;
  // напечатает 1
  printf("x = %zu\n", value);
  // напечатает 2
  printf("x = %zu\n", ++value);
  // напечатает 2
  printf("x = %zu\n", value);
  // напечатает 4
  printf("x = %zu\n", ++++value);
  // напечатает 4
  printf("x = %zu\n", value++);
  // напечатает 5
  printf("x = %zu\n", value);
  // напечатает 4
  printf("x = %zu\n", --value);
  // напечатает 4
  printf("x = %zu\n", value--);

  // напечатает 3
  printf("x = %zu\n", value);

  // тут маса вариантов
  ++value = value++;

  // будет 3
  printf("x = %zu\n", value);
  /*
    value++, возращает 3, и увеличивает value на 1
    value == 4, уверличивает value на 1 и присваивает ему 3
    такое поведение компилятором есть неопределенное, и не стоит так писать
  */

  // напечатает 14, operation on ‘value’ may be undefined
  auto value2 = (++value * 2) + (value++ + 2);

  printf("x = %zu\n", value2);

  // будет ошибка компиляции
  // value2++ = value; 
  return 0;
}

```
Чаще всего операцию инкремента и декремента используют, для индексации счетчика прохода по массиву, т.е. как счетчик в цикле.

### Операции отношения
Оперция отношения служат для того чтобы сравнить два операнда на эквивалентность, больше или меньше. Результатом этих операций естьвременное булевое выражение true или false(истина или ложь). Чаще эти операции применяються в условных операторах или циклах. Но можно присваивать и переменным, чаще это делают для bool типа данных.
Операции отношения есть бинарными операциями, т.е. в сравнении участвуют два операнда. Результатом логической операций есть rvalue, но в качестве операндов может быть как rvalue так lvalue
Сужествуют следующие операции отношения
```
== равно
!= неравно
> больше
< меньше
>= больше либо равно
<= меньше либо равно
```
```cpp
#include <iostream>
#include <iomanip>

int main(int argc, char const *argv[]) {
    bool value = 10 > 5;
    std::cout << std::boolalpha;
    std::cout << value << std::endl;

    value = 10 < 5;
    std::cout << value << std::endl;

    value = 10 == 10;
    std::cout << value << std::endl;

    value = 10 == 10;
    std::cout << value << std::endl;

    value = 10 >= 9;
    std::cout << value << std::endl;

    value = 10 <= 20;
    std::cout << value << std::endl;

    value = 10 != 20;
    std::cout << value << std::endl;

    int value2 = -130;

    // это частая такая ошибка в программировании, вместо оператора == ставят оператор =, результатом всегда будет истина
    // компилятор выдаст варнинг, но для начинающих он немного не понят
    value = value2 = 15;
    std::cout << value << std::endl;

    // это способ решения проблемы, внезапного присвоения переменной значения, rvalue неможет стоять в левой части оператора =
    // value = 15 = value2;
    
    int value3 = 30;

    // но такую ошибку сложно уже отловить, способы ее решения могут быть следующие
    value = value3 = value2;
    std::cout << value << std::endl;
    // делать явное преобразование к константе
    // value = (const int)value3 = value2;
    // начиная с С++11
    // value = (int &&)value3 = value2;
    
    return 0;
}
```
### Логичееские операции
Операторы отношения они проверяют только одно условие, но необходимы операторы для объединения нескольких условий. Для этого использую логические операции:
```
&& - логическое и, возвращает true только если оба операнда равны true
|| - логическое или, возвращает true, если один из операндов равен true
``` 
Перечисленые операторы являються бинарными

```
! - логическое отрицание, т.е. делает обратное, если выражение равно true, то отрицание даст false или наоборот
```
```cpp
#include <iostream>
#include <iomanip>

int main(int argc, char const *argv[]) {
    std::cout << std::boolalpha;

    int a = 41;
    // проверка диапазона (20, 40] 
    bool is_access = a > 20 && a <= 40;
    std::cout << is_access << std::endl;

    is_access = a == 20 || a == 41;
    std::cout << is_access << std::endl;

    is_access = !(a == 20 || a == 41);
    std::cout << is_access << std::endl;

    // если применить к выражению закон де моргана
    is_access = !(a == 20) && !(a == 41);
    std::cout << is_access << std::endl;

    bool flag = false;

    a = 101;

    is_access = a > 100 && flag;

    std::cout << is_access << std::endl;

    is_access = !(a > 100 && flag);
    std::cout << is_access << std::endl;
    // выражение выше соответствует закону де моргана
    is_access = !(a > 100) || !flag;
    std::cout << is_access << std::endl;

    auto value = 1;
    is_access = value != 0 && a > 100;
    std::cout << is_access << std::endl;

    // в силу того что неявно в С++ целый тип может преобразовываться в bool
    is_access = value && a > 100;
    std::cout << is_access << std::endl;
    // по правилам перобразования все что не 0 это true
    value = 0;
    // такую конструкцию !value, но этим просто означает что проверяют на ноль
    is_access = !value && a > 100;
    std::cout << is_access << std::endl;
    
    // в выражения может присутсвовать смешаные логические операторы
    is_access = (a > 101 && a < 200) || !value;

    is_access = ((a > 100) && printf("a > 100\n"));
    is_access = ((a == 101) && printf("a == 101\n"));
    is_access = ((a > 101) && printf("Not printed\n"));
    is_access = (value || printf("Printed because value is equal zero\n"));
    is_access = (!value || printf("Not printed\n"));
    (void)(!value && ++value < 3 && ++value < 3 && ++value == 3 && printf("value %d\n", value)); 
    return 0;
}
```
Важным замечание, в приведеным примере выше, бинарные логические операторы, выполняються со следующим условием:
- В операторе && если первый операнд равен false, то второй операнд выполнятся не будет
- В операторе || если перавый оператор ранвен true, то второй оператор проверяться не будет
Это очень полезно при проверке многих условий

### Битовые операции
Ну как звучит из названия битовые операции служат для работы с битовой арифметикой. Различают следующие битовые операции:
- & порязрядно битовое умножение, истино только если оба бита истины
- | поразрядное битовое сложение, истино если хоть один из битов истиный
- ~ битовое отрицание, т.е инверсия всех битов
- >> сдвиг вправо на укащаное количесвто битов
- >> сдвиг влево на укащаное количесвто битов
- ^ исключающее или, т.е. равно истине если один из опрендов истино, а другой ложь(имеет многое применение)
```cpp
#include <cstdio>
#include <cstdint>
#include <limits>
#include <bitset>

/*
 сдвиг влево <<, x << y это равносильно умножению x * 2^y 
 сдвиг вправо >>, x >> y, наоборот эквивалентно делению x / 2^y, прошу заметить что деление целочисленное 
 если один из операндов битового сдвига отрицательное число то это неопределенное поведение -1 << 1
*/
void ShiftLeftRight(int value, int shift) {
   printf("%d << %d == %d === %d * (2^%d)\n", value, shift, value << shift, value, shift);
   printf("%d >> %d == %d === %d / (2^%d)\n", value, shift, value >> shift, value, shift);
}

bool isOdd(int value) {
  return !!(value & 1);
}

int main(int argc, char const *argv[]) {
   uint16_t value = 0b000'000'000'000'010'0;
   printf("value = %d\n", value);
   uint16_t value2 = 0b000'000'000'000'000'1;
   // Пример установки бита
   /*
     000'000'000'000'010'0
                           |
     000'000'000'000'000'1
     ---------------------
     000'000'000'000'010'1 == 5 --> 2^0 + 2^2
   */ 
   printf("value | value2 = %d\n", value | value2);
   
   value2 = 0b111'111'111'111'101'1;
   // пример сбросить бит
   /*
     000'000'000'000'010'0
                           &
     111'111'111'111'101'1
     ---------------------
     000'000'000'000'000'0
   */ 
   printf("value & value2 = %d\n", value & value2);

   // инверсия битов, таки способом можно получить максимальное
   /*
     ~ 000'000'000'000'010'0
     ---------------------
       111'111'111'111'101'1 = 
   */

   value = ~value;
   printf("~value = %d\n", value);

   // должны получить максимальное значение 16 битного разрадного числа 
   value = 0;
   value = ~value; 

   printf("~value = %d, max unsigned = %d\n", value, std::numeric_limits<uint16_t>::max());
   
   // должны получить максимальное знакового 16 битного числа
   
   value2 = 0b100'000'000'000'000'0;
   value = ~value2;
   printf("~value = %d, max signed = %d\n", value, std::numeric_limits<int16_t>::max());
   std::bitset<8> b(126);

   printf("bit of %d =>> %s\n", 126, b.to_string().c_str());
   printf("bit of %d =>> %s\n", 126, b.to_string('1', 'X').c_str());

   ShiftLeftRight(5, 1);
   ShiftLeftRight(9, 1);
   ShiftLeftRight(4, 2);
   ShiftLeftRight(8, 1);
   // также битовые операторы & и | применяються и с операторами отношения

   value = 0;
   (void)((!value) | printf("Print always\n"));
   (void)(value & printf("Print always\n"));
   // Разница в том что в таком случае будут выполняться/ проверяться оба операнда
   
   // Битовая арифметика применима только к целым числам 
   /*
     double value3 = 20.10;
     value3 >>= 2;
   */
   (void)(isOdd(19) && printf("Odd\n"));
   (void)(isOdd(20) && printf("Odd\n"));
   return 0;
}
```
При сдвиге в право и сдвиге влево, операнды не должны быть негативными
Сдвиг влево <<, x << y это равносильно умножению x * 2^y 
Сдвиг вправо >>, x >> y, наоборот эквивалентно делению x / 2^y, прошу заметить что все деление целочисленное
Также битовые операторы & и | могут применяються и с операторами отношения, разница между логическими в том что в таком случае будут выполняться/проверяться оба операнда.
Также битовые операции могут быть и составными(например >>= и т.д.)
Битовая арифметика применима только к целым числам, компилятор выдаст ошибку при попытке применить один из битовых операций к вещественному числу.
Ниже ссылка на пример как перчисления используються в качестве битовых полей.
Отдельной темой являееться битовая операция исключающее или, она часто применяеться в криптографии для шифрации и дешифрации, для генерации случайных чисел и т.д.
Также есть такое понятия как порядок байтов, т.е как представляються байты от младшего к старшему. На компьютере представляються как порядок от младшего к старшему(little-endian), а в сетевой архитекруте как от большого к младшему(big-endian). Для преобразования служит функции htol.. Т.е. преобразование между сетевым представлением числа в компьютерный.
### Операции применимы к типу char
отдельной темой я хотел бы написать это про применение  некоторых арифметических операций к типу char. Исторически так сложилось что тип char, на большинстве платформ, есть найменший тип данных 1 байт, и его применяли в языке С и С++ для работы с целыми числами, но также и использовали его для текствой информации
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
    char ch = 65;
    printf("%d is %c\n", ch, ch);

    ++ch;
    printf("%d is %c\n", ch, ch);

    ++ch;
    printf("%d is %c\n", ch, ch);

    --ch;
    printf("%d is %c\n", ch, ch);

    ch = (ch - 1) + 25;
    printf("%d is %c\n", ch, ch);
    return 0;
}

```
### Точки следования
Что это такое? Когда мы волняли с вами арифметичекие операторы, то компилятор выдавал предупреждения что мол значение переменной может быть не определенным после после выполнения некоторых операций, хотя есть понятия приоритетности, но проблема возникает когда приоритетность одна и таже, тогда компилятор сам(каким то своим магическим мышление как ему выполнять последовательность толи слева на право, то ли справа на лево). Часто в книгах пишут так нажываемые понятия что есть, например, оператор = и он выполняеться слева направо, это все верно вплане присвоение значения, но вот когда как в примере с инкрементом в левой и в правой частях присутсвут оператор инкремента, то компилятор предупреждает что вычисление выражения может быть не предсказуемым.
Но есть некоторые операторы в которых определены точки следования, т.е. гарантировано что все побочные эфекты предыдущих вычеслений уже проявились, т.е. все  вычесления выполнены. Мы уже расматривали операторы в которых были определены точки следования, это логические операторы, заметьте что не бинарные, а именно логические `&&`, `||`. Согласно которым первый операнд будет вычеслин одназначно, до выполнения второго операнда.
Другим примером есть

```
printf("%d is %c\n", ch, ch);
```

Согласно которому, все аргументы функции будут вычеслены до вызова функции, но порядок их вычесления не определен.
Точкой следования также есть оператор `;`, т.е. гарантировано до этого момента выражение будет вычеслено
https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%87%D0%BA%D0%B0_%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F

### Оператор ,
До этого мы уже встречали опреатор зяпатая, но у нее был другой контекст, это через запятую мы перечисляли аргументы в вызове функции `printf`, вторым примером это перечисление переменных через запятую. Но у нее есть другой контекст
```
x = (y, z);

```
Согласно описанию выше выражение у будет вычеслено, до выражения z, и результатом переменной x будет выражение z
Оператор запятая это еще один вид точки следования
```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
    unsigned value = 20;
    printf("value = %d\n", (++value, ++value + 20));

    printf("value = %d\n", (printf("Operator comma\n"), ++value));
    return 0;
}
```
### Оператор остаток от деления %
Отнситься к арифметическим операциям. Суть его простая, если целое число делиться без остатка то получим ноль, т.е. получаеться деления нацело например 10 поделить на 2 дает нам деление без остатка, а вот 9 уже нацело не делиться без остатка, т.е. грубым словом берем найбольшую часть делимого вообщем ищем найближнее делимое от 9. В нашем примере если 9 на 2 то ближайше делимое это 8 а остаток 1(это грубый пример)

https://naobumium.info/arifmetika/delenie2.php

Другой пример остаток от деления представляют как часовую стрелку, т.е. например
Берем в качестве делителя 12, и любой делимый будет попадать в эту часовой диапазон, как у нас 24 часа).
Ярким пример использования остатка от деления есть проверка числа на четное не четное. Вторым примером это разбиение числа на цифры, или получение последней цифры в числе, еще это перевод десятичного в двоичный формат
При работе с отрицательными числами поведение программы не определено