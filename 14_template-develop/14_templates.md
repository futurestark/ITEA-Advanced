# Шаблоны
В этом разделе мы будем рассматривать еще один подход к программированию или стиль программирования это обобщенное программирования. Так что такое обобщенное программирование и зачем оно нужно. Чтобы было более ясно о чем речь, обобщенное программирование можно сравнить с формулой. Формула есть общее понятие, она описывает суть, общность. Например получение площи квадрата, сама формула это общее описание, а вот определенные коэфиценты это ее реазилация. Но обобщеность имеет также некое ограничение, например коэфициент принадлежит только такому диапазону чисел, точно также и с обобщеностью на них тоже может накладываться ограничение.
В С++ обощенность выраженна понятием шаблона. Все понимаем что шаблон это некий каркас, или некая модель, т.е по шаблону мы создаем уже конкретную модель. Почти похожа аналогия с классами и объектом, где класс это чертеж, а вот объект это реализация этого чертижа.
Так а зачем такая обобщеность нужна в программировании? Мы уже применяли обощенность, добавляя в функцию сортировки, некий компаратор, смысл которого решить как будет у нас выполняться сортировка. Т.е. алгоритм знает как получить данные, а компаратор знает как сравнивать эти данные.
**Шаблон это простая кодо генерация** Идея шаблона сгенерировать конкретный участок кода! И проблема шаблонов как мы будем дальше видеть это **раздувания кода**
Но больше их применение это в динамических структурах. Ну сейчас мы поймем это.  
Забегая вперед мы в этом разделе рассмотрим только маленький кусочер шаблонов, так как тема шаблонов она требует больше времени, когда идет дело с продвинутой работой шаблонов.
В С++ выделяют шаблоны класса и  шаблоны функции.
## Макросы
При чем тут макросы. А при том. Выше я сказал что шаблон это простая генерация кода. А мы знаем что макрос это подстановка имени макроса его содержимым на этапе препроцесинга.
Давайте вернемся к нашему примеру стека. У него есть огромный недостаток, а именно в него можно сохранять только значение `int`. А мы знаем что стек это некая общая структура которая может работать(правильней сказать хранить) как с целыми, так с вещественными, так и пользовательские типы. Мы знаем что макрос это обычная подстановка текста. Ок давайте сделаем макрос которое в качестве параметров принимает тип имя этого стека.

Сам макрос
```cpp
#pragma once
#include "common_type.hpp"

#define STACK(Name, Type) \
class Stack##Name { \
  public: \
   Pair pop() { \
     Pair res {false, "Stack empty"}; \
     if (nullptr == array) { \
       res.msg = "Stack is not allocated"; \
       return res; \
     } \
     if (current_position == -1) { \
       return res; \
     } \
     --current_position; \
     res = {true, "Success"}; \
     return res; \
   } \
   Value top() const { \
     Value res {false, 0}; \
     if (nullptr == array) { \
       return res; \
     } \
     if (current_position == -1) { \
       return res; \
     } \
     res = {true, array[current_position]}; \
     return res; \
   } \
   Pair push(Type value) { \
     Pair res {false, ""}; \
     if (nullptr == array) { \
       res.msg = "Stack is not allocated"; \
       return res; \
     } \
     if (current_position == SIZE_STACK) { \
       res.msg = "Satck is full"; \
       return res; \
     } \
     array[++current_position] = value; \
     res.status = true; \
     res.msg = "Success add to stack"; \
     return res; \
   } \
   Stack##Name(int size) \
      : SIZE_STACK(size) { \
     if (SIZE_STACK > 0) { \
       array = new Type [SIZE_STACK]{}; \
     } \
   } \
  ~Stack##Name() { \
    if (array != nullptr) { \
      delete [] array; \
    } \
  } \
  private: \
   Type* array = nullptr; \
   int current_position = -1; \
   int SIZE_STACK = 5; \
};

```

Просто дичь! Т.е. видим что мы передаем имя нашего класса, и тип массива. Символ в `##` есть просто простая конкатенация строк на этапе препроцесинга. Также есть проблема в том что макрос это на самом деле однострочный оператор, и нам приходиться склеивать таким образом строки как макроса чтобы определить его как одну строку. Еще другая проблема что такой макрос мы не сможем определить раздельную компиляцию(отделив заголовочный файл от файла реализации)
Ок, и его использование в main
```cpp
#include <iostream>

#include "template_macros.hpp"

int main(int argc, char const *argv[]) {
  STACK(Int, int)
  StackInt st {10};

  STACK(Float, float)
  StackFloat st_new {10};

  return 0;
}

```
Видно что мы указываем имя макроса, которое будет заменено на строчку макроса которую мы определили в заголовочном файле. В итоге в первом случае нам компилятор подставит вместо макроса `STACK(Int, int)` объявление класса `StackInt`, а `Type` заменит на `int`. То же и касаеться для `float`.
Но самая большая проблема макроса это **проблема с раскрытием макроса**, т.е. макросы не есть типо безопасными. А именно сначало препроцессор ввиде строчки раскроет макрос, а потом только компилятор начнем смотреть в него синтаксическую корестность. И мы будем получать ошибки немного сложные в описании, и строчки которые соответсвуют строчкам раскрытия макроса, а не его описания.

##Шаблоны класса.
Макросы, это был хороший и популярный механизм, более мение близкий, к обобщеному программированию. Шаблоны как раз и призваны решить эти недостатки макросов. Механизм шаблонов похож на макросы, только:
1. Это конструкции языка, со всеми синтаксическими последствиями
2. Ошибки вы получаете уже на этапе компиляции, а не препроцессинга, т.е. получаете внеменяемую(читаемую) ошибку, строку, в коде.

Как было сказано проблема шаблонов, да и макросов, это раздувание кода. Ок давайте перепишем наш стек на шаблонный.
```cpp
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T>
class Stack {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE_STACK) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE_STACK;
  }

  int GetCurrentPosition() const {
    return current_position;
  }

  Stack(int size)
     : SIZE_STACK(size) {
    if (SIZE_STACK > 0) {
      array = new T [SIZE_STACK]{};
    }
  }

  Stack(const Stack& st)
    : Stack(st.SIZE_STACK) {
  }

  Stack() = delete;

  ~Stack() {
    if (array != nullptr) {
      delete [] array;
    }
  }

  Stack& operator=(const Stack& st) {
    if (this == &st) {
      return *this;
    }
 
    if (array != nullptr) {
      delete [] array;
    }
    current_position = st.current_position;
    SIZE_STACK = st.SIZE_STACK;
    array = new T[SIZE_STACK] {};

    for (decltype(SIZE_STACK) i = 0; i < SIZE_STACK; ++i) {
      array[i] = array[i + 1];
    }
    return *this;
  }
 private:
  T* array = nullptr;
  int current_position = -1;
  int SIZE_STACK = 5;
};

```
Как видно из реализации ничего не поменялось как с привычным нам объявлением, только добавилось слово `template` `class`. По порядку, `template`вы говорите компилятору что вы намереваетесь объявить шаблон. Дальше в угловых скобочках вы передаете тип(информацию для компиялтора что делать с этим классом) `<class T>`. Где `T` это имя типа которое  будет передваться при создании шаблона, на самом деле имя может быть любым это просто общее соглашение. ШАблон чем то похож на функцию, смысл которой работать с данными, т.е. данные передавались как параметр. Шаблоны они работают с типами.
Но при таком коде компилятор если мы добавим заголовочный файл, то компилятор может посмотреть только не которые общие синтаксические ошибки, иногда даже может и с оптимизировать и вообще этот шаблон не рассмартивать(бывает и такое), но полный анализ компилятор начнет делать когда мы создадим экземпляр такого шаблона.
```cpp
#include <iostream>

//#include "template_macros.hpp"
#include "template_class.hpp"

int main(int argc, char const *argv[]) {
  Stack<int> st{20};
  std::cout << st.GetMaxStackSize() << std::endl;

  Stack<float> st_float{20};
  std::cout << st.GetMaxStackSize() << std::endl;

  return 0;
}

```

Как видим с примера выше, наш код кардинально отличаеться от макроса, он есть частью привычной нам языковой конструкцией. Тут мы создаем(инстанцируем) два класса Stack c типами int и double.
Поговорим про создание. Не говорят создание шаблона. Говрят инстанцирование. В строке `Stack<int> st{20};` много интерсного.
1. При таком объявлении компилятор смотрит так есть у меня в системе такой интстанцирование (готовый уже клласс) шаблон класса с именем Stack. Ок, нет, но у меня есть шаблон по которому я могу это создать. И тут **важное** что компилятор до этой строки компилировал наш шаблон, как общий не в даваясь в конкретный тип. А вот после он уже инстанцировал конкретный класс с типом который мы передали в качестве параметра, и тут компилятор делает еще одну проверку мол типа а коректные конструкции, т.е. можна их ли применять, к этому типу передаваемого в наш класс. Т.е. синтаксически идет проверка уже нашого передаваемого типа для шаблона.

2. После уже синтаксического анализа типа и шаблона, компиялтор создает и иницализирует объект этого класса.

3. А если мы объявляем другую переменную этого типа, например `Stack<int> st_next{100};`, то компилятор увидет что уже есть экземпляр, установленный(грубое слово), шаблона и не будет больше гененрировать такой шаблон, а просто создаст перменную.

Т.е. вывод что инстанцирование, т.е. создание полного класса, и его анализ происходит только один раз.

Как я и говорил, что тип это подобие данных передаваемых в функцию, и также как в данных в шаблоне класса можно указывать дефолтный тип. Суть такого подхода такой же как и обычными данными, возможность опускать некоторые типы.
Типов в шаблоне можно передвать много, все они передаються через запятую, но только имя индетификатора типа, должно быть разное, а вот тип при создании шаблона, может повторяться.
Давайте в наш класс добавим дефолтный нам тип это тип `int`.
```cpp
template <class /*typename*/ T = int>
```
Как видим поменялась, только одна строка и все, в самом теле шаблона никаких изменений делать ненадо. Тут также как и по аналогии с даными, указали что если опустить тип при создании шаблона, то дефолтным типом будет `int`
Ну правда немного отличаеться вызов.
```cpp
  Stack<> st{20};
  std::cout << st.GetMaxStackSize() << std::endl;
```
Как видим нам всеравно надо указывать угловые скобочки, тем самым мы опускаем имя типа.

В шаблоны кроме типа можно передавать и значение. Давайте лучше пример. У нас есть динамический массив, но мы знаем что динамика ведет за собой  кучу проблем, а именно нам надо выделить эту память, освободить ее, да и плюс реализовать сейвед операции по работе с указателями, как конструктор копирования и т.д. Ну проблема стека остаеться, но иногда нам не нужно выделять память под стек, если размер его небольшой. Так как нам так сделать чтобы нам на статике, т.е. в стеке выделить память. Вот для этих целей и используют интегральные значения в качестве параметра шаблона.
```cpp
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T, unsigned SIZE>
class Stack {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE;
  }

  int GetCurrentPosition() const {
    return current_position;
  }
 private:
  T array[SIZE];
  int current_position = -1;
};

```

Смотрит что произошло с нашим кодом, у него удалилось много чего, динамика, и за ними не нужные конструкторы, и т.д. Это наш класс, который мы разрабатывали в самом начале. Но он даже еще лучше чем начальный.
1. Он может работать с разными типами
2. Что самое важное мы решили проблему с определением параметра для размера стека.

Темплейты рулят

Ок, скаже вы а если мне надо решить проблему, когда у меня будет большой размер стека. И тут нам на помощь приходит такое понятие как специализация. Сколько терминологии не интресной. Другим словом, мы должны сказать компилятору, что для такого типа наш класс будет работать по другому. Это аналогия как с перегрузкой только для класса.
Давайте напишим
```cpp

/*
Template specialization
*/
#pragma once
#include "common_type.hpp"

template <class /*typename*/ T, unsigned SIZE>
class Stack <T*, SIZE> {
 public:
  Pair push(T value) {
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }

  Pair pop() {
    Pair res {false, "Stack empty"};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }
    if (current_position == -1) {
      return res;
    }
    --current_position;
    res = {true, "Success"};
    return res;
  }

  Value top() const {
    Value res {false, 0};
    if (nullptr == array) {
      return res;
    }

    if (current_position == -1) {
      return res;
    }
    res = {true, array[current_position]};
    return res;
  }
  int GetMaxStackSize() {
    return SIZE;
  }

  int GetCurrentPosition() const {
    return current_position;
  }

  Stack() {
    std::cout << "Heap version" << std::endl;
    if (SIZE > 0) {
      array = new T [SIZE]{};
    }
  }

  Stack(const Stack& st) = delete;

  ~Stack() {
    if (array != nullptr) {
      delete [] array;
    }
  }

  Stack& operator=(const Stack& st) = delete;
 private:
  T* array = nullptr;
  int current_position = -1;
};
```

Как видим специализация, отличаеться от оригинального нашего класса, а именно добавлением после имени класса угловых скобочек, в которых мы указываем это класс шаблона отличаеться от базового если вы будете создавать этот класс для укзателей. Все просто
Круто у нас есть класс который может работать на стеке и на куче.
Как бы все что можно сказать для базового понимания шаблонов.

##Шаблоны функции
На ряду с шаблонами класса, есть также и шаблоны функции. Пример их это прямая аналогия с формулами. Только шаблонная  функция есть обобщенный алгоритм для множества наборов типа, которые удовлетворяют скажем некоторому условию
Пример, мой любимый, это сортирвка. Сортировка это обобщенный алгоритм, которому не важно какого типа элементы будут последовательности, лишь бы они удовлеворяли условию сравнения. При этом мы с вами рассмартивали что мы также условие сравнения можем обобщить. Например сравнивать значения двох `int`-ов мы можем, а вот сравнивать наверное класс машина мы должны по другому, для этого мы и обобщаем условие сортировки, компоратор.
Давайте добавим шаблонную функцию в наш класс. Вопрос, а как ведь это класс, а в классе метод. Так отвтет это то что методы это сахар компилятора и на самом деле это просто функция, т.е. которая принимает кроме явных параметров, один неявный. Вообщем.
Давайте как с нашим классом, только без шаблонов, мы в нем запрещали неявное присваивание несовметимых по типу элементы стека. Короче, делали `delete`. Но с шаблонами дело немного печальней. Так как шаблоны это есть обощенность, и на момент написания мы не можем предположить какие типы будут неявные для параметра шаблона. Это можно сделать определенным механизмом. Т.е. идея такая что в функции `push` мы должны сравнить тип класса с типом элемента который будет передаваться в метод `push`, и если они не равны то выдаем ошибку на этапе компиляции. Это аналогия того если мы бы сравнивали переменные на определенное условие.
```cpp
  template <typename U>
  Pair push(U value) {
    static_assert(std::is_same<T, U>::value, "Not equal parameter");
    Pair res {false, ""};
    if (nullptr == array) {
      res.msg = "Stack is not allocated";
      return res;
    }

    if (current_position == SIZE) {
      res.msg = "Satck is full";
      return res;
    }
    array[++current_position] = value;
    res.status = true;
    res.msg = "Success add to stack";
    return res;
  }
```

Как видим шаблоны функции такие же по сценарию как и шаблоны класса, только тип шаблона применяеться к параметру метода, тогда как шаболнный параметр класса применяеться ко всему классу. Важно то что имя шаблона функции должен отличаться от имени шаблона функции. В нашем примери мы используем еще один шаблон который на этапе инстанцирования класса, скажет совместимы типы параметра метода и параметра шаблона. Если нет то выдаст ошибку на этапе компиляции применив для этого функцию `static_assert`. Можно было бы и в рантайме выдавать ошибку используя `assert` или возращаемый тип, но лучше давать ошибку на этапе компиляцию, чем получать ошибку в рантайме.
Прменение
```cpp
  Stack<int, 255> st;
  st.push(20);
  // st.push(20.25);
  st.push<int>(100);
```
Как видите примение это функции выглядит очень просто как вызов обычного метода. В этом есть еще одно отличие класса, от функции а именно так называемым автоматическим выводом типа. Т.е. при вызове метода компилятор сам выведит тип шаблона с передаваемых аргументов функции. Тогда как класс, такого сделать не всиле. Но можно указать и явно, но выглядит как то не очень.

Ок давайте отвлечемся от нашего класса, и напишем функции логирования для разных типов
```cpp
#pragma once
#include <iostream>

template <typename T>
void LogError(T value) {
  std::cerr << "Error: " << value << std::endl;
}

template <typename T>
void LogInfo(T value) {
  std::cerr << "Info: " << value << std::endl;
}

template <typename T>
void LogDebug(T value) {
  std::cerr << "Debug: " << value << std::endl;
}
```

Как видим объявление этих функций выглядит также как и для обычных функций, только мы можем теперь логировать любой тип данных(не забываем о раздувании кода). Ну это надуманый функционал, в настоящем применении, он абсолютно бесполезен, т.к. логирование чаще принимает строку, или новомодную фичу variadic templates. Но это выходит за рамки этого курса.
А применение этих функций простое
```cpp
  LogDebug(st.pop().msg);
  LogDebug(st.pop().msg);
  LogError(st.pop().msg);
```
Ок все просто, согласен, но есть проблема а что если мы передадим в наш дебах указатель, то на экране мы получим не значение а адресс, наверное не то поведение, которе мы ожидаем. Давайте починим это сделав нам известную специализацию.
```cpp
/*specialization for pointers*/
/*template <typename T>
void LogDebug<T*>(T value) {
  std::cerr << "Debug: " << value << std::endl;
}*/

template<typename T>
void LogDebug(T* value) {
  if (value != nullptr) {
    std::cerr << "Debug with T* : " << *value << std::endl;
  }
}
```
Как видим частичная специализация шаблона не возможна с функциями, разрешено только полная специализация. Мы добавили шаблон с параметром указатель, который будет выводить не адресс а значение по адрессу. Ок запускаем нашу программу со следующими инстанцированиями
```cpp
  LogDebug(st.pop().msg);
  LogDebug(st.pop().msg);
  LogError(st.pop().msg);

  int a = 90;
  LogDebug(&a);

  float f = 90;
  LogDebug(&f);
```

Если мы запустим наш код то на экране вместо сообщений с возращаемого значения метода `pop`, получим первый символ. Чтобы исправить это давайте сделаем явную специализацию с параметром `const char*`
```cpp

template<>
void LogDebug<const char *>(const char* value) {
  std::cerr << "Debug with const char* : " << value << std::endl;
}
```

Вызываем и результат тот же, так компилятор посчитал что ему больше подходит общий шаблон с параметром указателя. А как исправить это, а мы явно в угловых скобочках для этой функции укажем явное типа параметра.
```
  LogDebug<const char* >(st.pop().msg);
  LogDebug<const char* >(st.pop().msg);
```

И о чудо на экране мы получим то что мы и ожидали)

Но на последок есть еще один нюанс с выводом типа, давайте напишем простую функцию для преобразования одного типа в другой применив для этого `static_cast`, т.е. пусть компилятор на этапе компиляции скажет где мы натупили.

```cpp
// common_type.cpp
template<typename R, typename T>
R convert(T value) {
  return static_cast<R> (value);
}
```

Как видим мы тут указали двапараметра первый это возращаемый тип, а второй это тип входного параметра.
И его применение
```cpp
// main.cpp
  std::cout << convert<float, int>(100) << std::endl;
  std::cout << convert<int>(100.30) << std::endl;
  // std::cout << convert<>(200.30) << std::endl;
```

Как видим мы в первом случае можем указать явно оба параметра.
Во втором случае мы может опускать тип для параметра функции, но **ВАЖНО** что тип для возращаемого значения мы должны явно указать, т.к. компилятор может вывести тип только для аргументов, но не для возращаемого значения. Тут еще важен порядок аргументов при описании шаблона, если мы бы указали на оборот `template<typename T, typename R>`, то пришлось бы явно указывать тип и для параметра функции и для возращаемого значения.
Пример как получить безопасно размер массива используя для этого шаблоны
```cpp
template<typename T, std::size_t N>
constexpr std::size_t arraySize(T (&)[N]) noexcept {
  return N;
}
```
и применение этой функции
```cpp
int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 };

int mappedVals[arraySize(keyVals)];
```