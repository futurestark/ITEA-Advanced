# Функции
## Что такое функция?
Часто можно слышать что функция это именованное объединение групы операторов, или позволяет выполнять логическое структурирование программы, или избежание повторяющихся кусков кода.
Но давайте разберемся немного глубже что такое функция.
В большинстве случаев это имя котрое объединяет групу операторов, выполняющих определенную задачу. И которое может быть вызвано в любой части программы.
Часто мы слышим такое понятие как алгоритм, так вот это и есть именованое структурированное объединение групы операторов выполняющих алгоритм. Давайте на примере рассмотрим алгоритм сортировки. Под именем `sort` мы понимаем что эта функция будет выполнять сортировку, или `pow` мы понимаем что эта функция возведет в степень число. Но не все функции можно назвать алгоритмами, часто это бывают подпрограммы некоторых алгоритмов, которые неназвешь алгоритмом, это просто некая структурированая група операторов которая даст более логическое структурированое понятие в том же самом алгоритме. Расмотрим пример сортировки данных в файле, псевдокод такой:
`
открыть файл
считать данные с файла
отсортировать данные в файле
вывести на экран
записать отсортированные данные в файл
закрыть файл
`
Как видим с перечисленных шагов у нас есть задача(функция) отсортировать данные в файле, она отличаеться от привычной задачи сортировки данных в контейнере, и нам надо специализировать ее для нашей задачи. В этой задачи(функции) мы разбиваем ее на подзадачи:

1. Подзадача открытия файла (назвать алгоритмом сложно, просто логически структурированная часть)
2. Подзадача чтения файла (алгоритмом назвать тоже сложно)
3. Отсортировать данные (это уже часть алгоритма).
4. Вывод на экран (алгоритмом назвать тоже сложно)
5. Подзадача записи в файл (алгоритмом назвать тоже сложно)
6. Закрытия файла.


Как видим мы одну задачу структурировали на несколько подзадач, и применили один общий алгоритм.
Алгоритм, это некий общий термин который позволяет разработчикам более общим прнятием общаться чем вдаваться в детали. Например сортировка, мы не говорим взять один контейнер, пробежаться по элемента контейнера, взять первый элемент сравнить со следующим, вообщем..... Мы говорим используй сортировку, и всем становиться все понятно.
Принимают также такое понятие как дублирование кода, например в вашем коде часто применяеться одинакова последовательность кода, ее сложно например назвать алгоритмом, но ее можно назвать логическим названием, для уменьшения так называемого копи паста).

Вообщем на этом можно и закругляться в описаниях функций, но все забывают важное понятие. Все мы знаем что такое функция `main`, все программы начинаються с нее, и все в один голос говорят что это точка входа в вашу программу. Ну ок. Так вот, другое важное свойство функции это точка входа в программу, т.е. с функции начинаеться выполняться другая логическая последовательность наша программа. Или подпрограмма, часто ее называют потоком, спомощью функции мы начинаем выполнять поток. Т.е. функция это еще выполнение программы или подпрограммы(грубо но ненашел других слов).
## Так что такое main?
Рассмотрев важное свойство функции в предедущем разделе, точка входа в программу, я бы хотел немного на этом остановиться подробней
Все наши примеры начинаються так

```cpp
#include <cstdio>

int main(int argc, char const *argv[]) {
  printf("Hello world");
  return 0;
}

```

И обьяснение мол типа main это функция которая являеться точкой входа в программу. И все???? А кто ее эту точку вызывает, есть некоторые объеснения мол это ОС, ну ок. А как она это делает, т.е. наш код есть некая подпрограмма более глобальной программы?
Ок, без лишних детальностей постараюсь показать что же всетаки происходит
Хочу заметить что таких main-ов бывают разные взависимости от контекста, кернел разработка, или библиотека для Win платформы, и т.д.
Мы знаем что есть такие понятия как глобальные переменные и статические переменные, которые инициализируються по стандарту до вызова main, т.е есть какие то инструкции предшествующие нашему main.
Давайте скомпилируем наш код, и посмотрим размер нашего код, только без лишних флагов оптимизации)
g++ main.cpp -o main
Смотрим размер, у меня это 8.2Кб??????? на такую маленькую программу столько памяти, ну ладно давайте уберем печать `Hello World` на консоль, т.е лишимся препроцессора). Убрав `include` и вызова функции печати на консоль, размер получили 8Кб????? Так что же там за такой код)
Проблема в том что при линковании нашей программы линковщик(crt1.0 наверное), добавляет(или наверное верней будет линкует) стартап файлы с многими новыми именами для нашей функции.
Что бы в этом убедиться слинкуем нашу программу с опрцией `-nostdlib`. На выходе получим странный варнинг `/usr/bin/x86_64-linux-gnu-ld: warning: cannot find entry symbol _start; defaulting to 00000000000002b1`, но размер нашей программы уменьшился, правда не значительно. Как видим стандартная библиотека `libc` добавляет много нового в наш код). Давайте разберемся с этим новым кодом)
Соберем нашу программу без опции `-nostdlib`. И выполним важную команду `objdump -t main` и на экране мы увидем многооооо интересной информации в виде таблицы символов (в основном используеться транслятором в которой каждый индетификатор переменной или функции асоциируеться с информацией)
```
main:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000238 l    d  .interp	0000000000000000              .interp
0000000000000254 l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
0000000000000274 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
0000000000000298 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000000002b8 l    d  .dynsym	0000000000000000              .dynsym
0000000000000348 l    d  .dynstr	0000000000000000              .dynstr
00000000000003c6 l    d  .gnu.version	0000000000000000              .gnu.version
00000000000003d8 l    d  .gnu.version_r	0000000000000000              .gnu.version_r
00000000000003f8 l    d  .rela.dyn	0000000000000000              .rela.dyn
00000000000004b8 l    d  .init	0000000000000000              .init
00000000000004d0 l    d  .plt	0000000000000000              .plt
00000000000004e0 l    d  .plt.got	0000000000000000              .plt.got
00000000000004f0 l    d  .text	0000000000000000              .text
0000000000000684 l    d  .fini	0000000000000000              .fini
0000000000000690 l    d  .rodata	0000000000000000              .rodata
0000000000000694 l    d  .eh_frame_hdr	0000000000000000              .eh_frame_hdr
00000000000006d0 l    d  .eh_frame	0000000000000000              .eh_frame
0000000000200df0 l    d  .init_array	0000000000000000              .init_array
0000000000200df8 l    d  .fini_array	0000000000000000              .fini_array
0000000000200e00 l    d  .dynamic	0000000000000000              .dynamic
0000000000200fc0 l    d  .got	0000000000000000              .got
0000000000201000 l    d  .data	0000000000000000              .data
0000000000201010 l    d  .bss	0000000000000000              .bss
0000000000000000 l    d  .comment	0000000000000000              .comment
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
0000000000000520 l     F .text	0000000000000000              deregister_tm_clones
0000000000000560 l     F .text	0000000000000000              register_tm_clones
00000000000005b0 l     F .text	0000000000000000              __do_global_dtors_aux
0000000000201010 l     O .bss	0000000000000001              completed.7696
0000000000200df8 l     O .fini_array	0000000000000000              __do_global_dtors_aux_fini_array_entry
00000000000005f0 l     F .text	0000000000000000              frame_dummy
0000000000200df0 l     O .init_array	0000000000000000              __frame_dummy_init_array_entry
0000000000000000 l    df *ABS*	0000000000000000              main.cpp
0000000000000000 l    df *ABS*	0000000000000000              crtstuff.c
00000000000007d4 l     O .eh_frame	0000000000000000              __FRAME_END__
0000000000000000 l    df *ABS*	0000000000000000              
0000000000200df8 l       .init_array	0000000000000000              __init_array_end
0000000000200e00 l     O .dynamic	0000000000000000              _DYNAMIC
0000000000200df0 l       .init_array	0000000000000000              __init_array_start
0000000000000694 l       .eh_frame_hdr	0000000000000000              __GNU_EH_FRAME_HDR
0000000000200fc0 l     O .got	0000000000000000              _GLOBAL_OFFSET_TABLE_
0000000000000680 g     F .text	0000000000000002              __libc_csu_fini
0000000000000000  w      *UND*	0000000000000000              _ITM_deregisterTMCloneTable
0000000000201000  w      .data	0000000000000000              data_start
0000000000201010 g       .data	0000000000000000              _edata
0000000000000684 g     F .fini	0000000000000000              _fini
0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000201000 g       .data	0000000000000000              __data_start
0000000000000000  w      *UND*	0000000000000000              __gmon_start__
0000000000201008 g     O .data	0000000000000000              .hidden __dso_handle
0000000000000690 g     O .rodata	0000000000000004              _IO_stdin_used
0000000000000610 g     F .text	0000000000000065              __libc_csu_init
0000000000201018 g       .bss	0000000000000000              _end
00000000000004f0 g     F .text	000000000000002b              _start
0000000000201010 g       .bss	0000000000000000              __bss_start
00000000000005fa g     F .text	0000000000000012              main
0000000000201010 g     O .data	0000000000000000              .hidden __TMC_END__
0000000000000000  w      *UND*	0000000000000000              _ITM_registerTMCloneTable
0000000000000000  w    F *UND*	0000000000000000              __cxa_finalize@@GLIBC_2.2.5
00000000000004b8 g     F .init	0000000000000000              _init
```

Много всего, да?)
Но разберемся последовательно.
Давайте переименуем функцию `main` в нашей программу на `test`, и попытаемся ее скомпилируем, то получим следующее
```
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status

```

Как видим с ошибкилинковки, что нашу функцию вызывает некая функция `_start`. И правда если посмотреть по таблице символов то мы видим что в ней есть такая фунция. Даже если введем следующую команду
```
objdump -f main
```
То увидим что стартом нашей программы будет следующий адресс
```
main:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000150:
HAS_SYMS, DYNAMIC, D_PAGED
start address 0x00000000000004f0

```
И посмотрим этот адресс в таблице символов
```
objdump -t main | grep 04f0

00000000000004f0 l    d  .text	0000000000000000              .text
00000000000004f0 g     F .text	000000000000002b              _start
```
Как видим `_start` и есть точкой старта в нашу программу с точки зрения линкера.
Сама функция `_start` живет в исходниках `libc`, `https://github.com/lattera/glibc/blob/master/sysdeps/i386/start.S`
Как видно с исходников она делает много работы, инициализирует стек, и т.д., на самом деле это хорошо коментируемый код. Но нас интересует вызов другой функции `call __libc_start_main@PLT`. Т.е. нам надо найти реализацию этой функции, ок не проблема `https://github.com/lattera/glibc/blob/master/csu/libc-start.c`. В этом коде тоже много всего интересного, но интересует другая нас часть
```
#else
  /* Nothing fancy, just call the function.  */
  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
#endif

```
Т.е. вот кто вызывает нашу функцию `main`.

Давайте немного подытожим, простым словом `main` есть точкой входа в программу, но это если сказать чтобы от тебя отстали, но если правильно то происходит куча всякой инициализации для `libc`, а потом только вызов `main`. Т.е. `main` это наша  логическая точка входа в программу для выполнения нашего кода, но для системы это не есть точкой входа для нее есть `_start` и т.д.

http://coding.derkeiler.com/Archive/C_CPP/comp.lang.c/2008-04/msg04617.html
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

## Две части функции
Функция делиться на две части. Это объвление функции(иногда называют прототипом, интерфейсом), и определения функции.
Объявление функции мы сообщаем читающему наш код или использующему нашу библиотеку, что делает наша функция, какой у нее интерфейс(т.е. какие параметры, что она возращает) и т.д. Но важной особеностью объвления это вы сообщаете компилятору, что есть такая функция с таким именем, с таким типом, но она может быть определена в текущем модуле трансляции, так и в другом(то уже задача линкера). Т.е. компиялтор по интерфейсу имени проверяет а правильного вы типа передали туда переменные, правильное количество, правильное вы используете возращаемое значение. Стоит сказать что объявлений может быть очень много в коде.
Определение это уже что делает ваша функция, т.е. что она делает с вашими параметрами и как возращает значение, если оно таковое есть. И определение функции должно быть только одно. Если не будет определена функция, или линкер ее не сможет найти, то он выдаст ошибку `undefined reference`, т.е. он на основе интерфейса не может связать имя с ее реализацией, т.е. не может найти где на нее ссылаться.

```cpp
long test(int a, int b);
long test(int a, int b);
long test(int a, int b);
long test(int a, int b);
long test(int a, int b);
int main(int argc, char const *argv[]) {
  return 0;
}

long test(int a, int b) {
  return a + b;
}

/*long test(int a, int b) {
  return a + b;
}*/

```

Как видим с примера мы можем объвлять функцию сколь угодно раз, но определять только один раз(т.е. действует правило ODR).

Я думаю после этого понятно почему функция  main должна быть только одна в коде.
## Синтаксис функции
Функция имеет следующий синтаксис
```
тип_возвращаемого_значения имя_функции (список параметров) спецификатор {
  тело функции
}
```
С описания все просто) Простым словом у функции есть имя (которое соответсвет правилам индетификаторам, и служит логическим описание что делает функция), есть входные данные определяемые `список параметров `, над которыми она выполняет некие действия, и выходные данные  определяемое `тип_возвращаемого_значения`. И `тело функции` выполняющую группу логически связанных операторов.

## Список параметров
Список параметров это данные с которыми будет работать ваша функция. Количество памраметров ограничиваеться только размером стека, т.е. размером памяти.
Сам параметр это как объвление обычной переменной(имеет тип и название). Список параметров разделяеться запятой, т.е. так же как и при объвляения переменных имена параметров должны быть разными. Дальше эти параметры будут использоваться в теле функции и как обычные переменные. Параметры это копии или ссылочные значения их оригинальных параметров, т.е. тех параметров которые были переданны при вызове функции.
Часто такие понятия называют фактическими и формальными параметрами
```
long calc(int a, int b) {
  return a + b;
}

....
int a = 40;
int b = 50;
calc(a, b);
``` 
В примере выше параметры в функции `calc` есть формальными параметрами их фактических параметров `a и b` при вызове функции.

Стоит заметить что в С++ нет такого понятия как позиционная передача параметров(хотя пропозолов по этому поводу есть очень много), и это может быть причиной логической ошибкой при передаче параметров одного типа. Например:
```
void move(float x, float y)
```

С примера выше видно что можно передать не правильные координаты, поменяв их местами. Есть масса способов это бороть, один из них это применение пользовательских типов.

Список параметров может и отсутсвовать, т.е. функция может и не принимать параметров, в этом случае просто пишут пустые скобочки, скобки нельзя опускать, должны писаться объязательно например
```cpp
bool HasInternetConnection();
или
bool HasInternetConnection(void); // но это редкий случай что так пишут
```

Также при перечеслении параметров, тип  необходимо писать перед каждой переменной.
```
long calc(int a, int b); // правильное написание

long calc(int a, b); // являеться синтаксической ошибкой
``` 

Можно также некоторым аргументам задавать значения по умолчанию, и при вызове функции аргумент у которого установлен значение по умолчанию, можно опускать, и параметр будет проинициализирован при вызове функции этим аргументом по умолчанию. Т.е. это похоже на объявление с инициализацией. Параметры по умолчанию должны идти с права на лево, нельзя для одного параметра указать значение по умолчанию, потом для другого опустить, а для следующего задать
Например
```cpp
#include <cstdio>

// компилятор выдаст ошибку компиляции,
// в том что мы пропустили значение по умолчанию для второго аргумента
/*long calc(int a = 10, int b) {
  return a + b;
}*/

long calc(int a, int b = 5) {
  return a + b;
}

int main(int argc, char const *argv[]) {
    printf("calc(10, 20) == %ld\n", calc(10, 20)); // 30
    // в примере параметр b будет инициализирован значением по умолчанию 5
    printf("calc(10, 5) == %ld\n", calc(10)); // 15
    return 0;
}
```

Имена параметров могут быть опущены, т.е. их писать не объязательно, но тип указывать объязательно. Часто такой подход имеет место при объявлении функции, т.е. показывают какие типы аргументов принимает функция. Компилятору впринципе при объявлении не важно имя переменной, т.к. ему нужен только интерфейс, т.е. типы аргументов, чтобы выдать ошибку при несоответсвии типа. Также имя переменной можно опускать и при определении функции если переменная не будет использоваться в теле функции. Но при вызове функции значение для этого параметра все равно надо передавать. Можно также для опускающего имени параметра указывать аргумент поумолчанию. Например:

```cpp
#include <cstdio>
#define __UNUSED__

int calc(int, int = 5);

void movePerson(float x, float y, float /*z*/__UNUSED__) {
  printf("Move person x == %f y == %f\n", x, y);
}

int main(int argc, char const *argv[]) {
    printf("calc(5, 20) == %d\n", calc(5, 20));
    printf("calc(5, 5) == %d\n", calc(5));
    movePerson(0.5f, 1.5f, 1.1f);
    return 0;
}

int calc(int a, int b) {
  return a + b;
}
```

Параметры в функцию могут передаваться двумя способами, передача по значению, передача по ссылке, и передача через указатель. Проще сказать что это работа с копией объекта и работа со самими напрямую переменными(т.е. возможность их изменять).

## Возвращаемое значение функции
Функции могут как возвращать значение, так и не возвращать.
Возвращаемое значение характеризуеться ключевым словом `return` за которым следует выражение, переменная или может отсутсвовать результат возврата, в этом случае это просто прерываение выполнение функции. Функции не возвращающие значения редко называют процедурами, и позначаються ключевым словом `void`, это даже не ключевое слово это как маркер ничего(недействительный).
Возращаемое значение случит результатом выполнения функции, это может быть вычеслительный результат(функция `pow`), логический(например `isdigit` т.е. проверка являеться символ цифрой), и системной(т.е. возврат кода ошибки). Но их может быть много и других.
В теле функции оператор `return` может встречаться в многих местах, но выражение после `return` должно быть возможным преобразовываться в тип возращаемого значения указаного в объявления функции.
Функция которая не возвращает значение неявнням выходом с функции, если не указано явно `return`, есть последняя закрывающая скобочка `}` в теле функции.
Если функция в которай указан тип возращаемого значения, но в теле функции не указан опреатор `return` или указан пустым, то мы получим ошибку компиляции.
```cpp
#include <cmath>
#include <cstdio>

double calcSqrt(int a) {
  if (a >= 0) {
    return sqrt(a);
  } else {
    // получим ошибку компиляции что return без значения
    // return;
    // получим ошибку несовместимости типов
    // return &a;
    // return 0;
  }
}

bool isDigit(unsigned char ch) {
  return (ch >= 48 && ch <= 57);
}

auto calcSumm(int a, int b, int c) -> decltype(a + b + c) {
  return a + b + c;
}


/*auto errorDeducation(bool val) {
  if (val) {
    return 123; // возвращаемый тип int
  } else {
    return 3.14f;   // ошибка: возращаемый тип float
  }
}*/

int main(int argc, char const *argv[]) {
  printf("Sqrt(10) == %lf\n", calcSqrt(10));
  printf("isDigit('a') == %s\n", isDigit('a') ? "true" : "false");
  printf("isDigit('1') == %s\n", isDigit('1') ? "true" : "false");
  printf("isDigit('&') == %s\n", isDigit('&') ? "true" : "false");
  printf("calcSumm(10, 5, 15) == %d\n", calcSumm(10, 5, 15));
  // printf("errorDeducation(0) == %d\n", errorDeducation(false));
  return 0;
}

```
Как видно из примера выше начиная с С++11 с появление ключевого слова `auto`, вывод типа также возможен и для возращаемого значения функции. Вывод возвращаемого значения также включает все правила как и для обычных правил вывода типа. Вывод типа не возможен, если несколько операторов `return` будут иметь разные типовые возвращаемые зачения. Но есть и одно отличие, если при автоматическом выводе типа в нескольких операторах `return` указать разные несовместимые типы, например `float и int`, то компиялтор выдаст ошибку что он незнает какой тип ему надо вывести.
Таже при использовании автоматического вывода типа, испольуют так называемый конеччный типы возврата, это больше полезно при выводе типа в шаблонах. Но это применение больше имело место до 14го стандарта, когда правила вывода типа были более ожесточенные. Вообщем правило такое если компилятор не справляеться в автоматичским выводом типа, или неправильно для нас его выводит то мы можем ему помочь спомощью конечного типа возврата.
## Способы передачи параметров в функцию
### Передача по значению
Этот способ передачи это простое копирование одних переменных(фактических) в другие (в формальные). Т.е. любые изменения сделаные с формальными параметрами никак не влияют на актуальные параметры (фактические параметры). Это самы простой способ передачи. Т.е. у нас разные копии объектов котрые не влияют друг-на-друга. Иногда аргумент указывают как `const`, и говорят что это бесполезное ведь мы никак не изменим оригинальное значение, это правда, но модификатор `const` полезный в том случае если необходимо указщать что значение переменной не измениться на протяжении выполнения функции. Также аргументы функции могут быть указаны c помощью ключевого слова `auto`. Вывод типа для аргументов соответсвует тем же првилам что и для обычных переменных `auto`. Но при использовании аргументов с `auto` возникает вопрос а каким типом должно быть возвращаемое значение? И тут нам на помощь приходит конечный тип возрата. Но автоматический вывод типа возможен только без использвании опции `-pedantic` 
```cpp
#include <cstdio>

void justPrint(int a, int b) {
  printf("%s\n", __func__);
  a = 10;
  printf("a == %d\n", a);
  b = 25;
  printf("b == %d\n", b);
}

auto multiply(int a, int b) /*-> decltype(a * b)*/ { // trailing return type начиная с C++14 не объязателен
  printf("%s\n", __func__);
  return a * b;
}

int main(int argc, char const *argv[]) {
  int a = 40;
  int b = 88;
  printf("%s\n", __func__);
  printf("a == %d\n", a);
  printf("b == %d\n", b);
  justPrint(a, b);
  printf("%s\n", __func__);
  printf("a == %d\n", a);
  printf("b == %d\n", b);
  printf("multiply(%d, %d) == %d\n", a, b, multiply(a, b));
  return 0;
}
```
Как видим с примера выше конечный тип возрата, есть не объязательный начиная с С++14.
### Передача по указателю
Как мы знаем с предыдущих разделов указатель это просто переменная хранящая адресс другой переменной. И в связи с этим это один из способов, скажем так это способ есть наследия языка С, изменения фактического параметра, т.е. работать с оригинальным значением переменной посредсвом косвенной адресации.
Мы знаем что переменная указатель это переменная со своей областью памяти, и тоже самое касаеться и при аргументах функции, т.е. мы выделяем новую переменную на стеке и копируем туда адресс переменной которая хранится в фактической переменной. Важным в этом случае становиться понятие константности данных куда указывает указатель, ведь это становиться логичным если мы работаем с оригинальным значением.
Зачем вообще передавать параметры которые могут меняться в теле функции? Это было необходимо в ряде случаев:
1. Это возможность возврата с функции нескольких значений
2. Возможность передачи массива(в случае указателя)
3. Возможность избежания тяжоловесного копирования пользовательських объектов.

Как видно из перечисленного важное это возврат нескольких значений. Но более весомым есть избежанияе копирования больших объектов.

Важность указателей как аргументов функции есть то что в Google code style прописано, что значение которое может быть изменено в теле функции должно передаваться по указателю.
Вопрос почему так? Ответ как по мне заключаеться в том как передаються фактические параметры в функцию. Пример:
```cpp
void swap(int* a, int* b);

....
int a = 40;
int b = 50;
swap(&a, &b);
```
С примера выше видно что при вызове функции мы явно указываем что мы хотим изменить значение этой переменной.

Мы знаем что указатель может как содержать адресс другой переменной так и null, из этого следует что перед разыменование указателя необходимо его проверить на null. Это очень важное замечание.
Часто у новичков есть ошибка это возрат из функции адресса локальной переменной. Это результат прриводит к неопределенному поведению, т.к. мы знаем что локальная переменная имеет автоматическую область зранения(другим словом живет на стеке), и после возврата из фунции она недействительна, т.к. фрейм стека очищаеться, т.е адресс функции как может быть так и не может быть. Т.е. разыменование такойго указателя может привести в падению программы.
```cpp
#include <stdio.h>

void copy_swap_func(int a, int b) {
  int tmp = a;
  a = b;
  b = tmp;
}

void swap_func(int* a, int* b) {
  if (a != nullptr && b != nullptr) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
  } else {
    printf("One of the argument is null\n");
  }
}

/*void inc_value(auto* a, auto* b) { // build without -pedantic flag
    ++*a;
    ++*b;
}*/

int main(void) {
  int first_value = 10;
  int second_value = 20;
  printf("Before swaping first value is %d second value is %d \n", first_value, second_value);
  copy_swap_func(first_value, second_value); // ничего не измениться т.к. внутри функции происходим обмен данными для копий
  printf("After swaping first value is %d second value is %d \n", first_value, second_value);
  swap_func(&first_value, &second_value);
  printf("After ptr swaping first value is %d second value is %d \n", first_value, second_value);
  swap_func(&first_value, nullptr); // напечатаеться сообщение что один из аргументов null

  inc_value(&first_value, &second_value);
  printf("increment value %d %d\n", first_value, second_value);
  return 0;
}
```
Как видим к указателям модно тоже применять автоматическое выведения типа, если не применять флаг компиляции `pedantic`
Как мы знаем адресс указателя это просто целочисленное значение, т.е. мы может в качестве параметра указателя передавать просто целочисленный литерал.
```cpp
void printPointerValue(int* ptr) {
  printf("%s\n", __func__);
  printf("value is %d\n", ptr);
}

....
printPointerValue((int *)(20));

```
#### Массивы как аргумент функции
### Передача параметров по ссылке
#### Ссылки
Простым словом ссылка это некий алиас на существующий объект. Т.е. ссылка разделяет один и тот же адресс с переменной на которую сылается ссылка.
Сылка появилась в языке С++ как следствия больших проблем с указателями. Т.е. сылки считаються намного безопасней чем указатели. Давайте все постепенно рассмотрим.
Синтаксис сылки следующий
```
cv тип& имя_ссылки = инициализируещее_выражение;
```
С выше перечеслиненого синтаксиса вытекает новое применение символа `&`, первое его примение это получения адреса lvalue, а второе это как часть типа в данном контексте это ссылка.
Важным отличием от указателя согласно синтаксису, это то что ссылка должна быть всегда проинициализирована, т.е. нельзя взять объявить ссылку а потом проинициализировать. Т.е. ссылки становяться безопасней так как не могу быть null. Ссылка в отличии от указателя не можна переинициализировать другой переменной. Другим важным и значимым отличием это то что ссылки могут ссылаться на rvalue, и расширять время жизни временной переменной. Но это касаеться только скопа применения этой временой переменной, отличаеться от функции. Ссылки могут быть константными так же как и указатели.
Иногда приводят аналогию с указателями, мол ссылка это константный указатель(не путать с указателям на конст), т.е. сам указатель менять нельзя, а вот значение можно. Но еще раз это просто аналогия, т.е. ссылка это так называемый синтаксический сахар. Т.е. реализация ссфлки поднизом может быть разная.
Но помнить надо всегда что ссылка это объект, а указатель это указатель. Если взять размер ссылки, то мы получим размер объекта на который ссылка ссылаеться, а если взять размер указателя то мы получим размер указателя. Указатель иммет свой адресс, тогда как ссылка разделяет тот же адресс с переменной на которую ссылаеться. Очень важно то что указатель это перемення которая содержит адресс!!!!! Проще думать что ссылка это просто другое имя переменной.
Хотя проведя некоторые иследования на ассеблерном уровне, следующего кода
```cpp
// Type your code here, or load an example.
int test() {
    int a;
    int &b = a;
    return a;
}

// Type your code here, or load an example.
int test() {
    int a;
    int *ptr = &a;
    return a;
}
```

То мы получим одинаковую реализацию на ассемблерном уровне
```
test():
        push    rbp
        mov     rbp, rsp
        lea     rax, [rbp-12]
        mov     QWORD PTR [rbp-8], rax
        mov     eax, DWORD PTR [rbp-12]
        pop     rbp
        ret


test():
        push    rbp
        mov     rbp, rsp
        lea     rax, [rbp-12]
        mov     QWORD PTR [rbp-8], rax
        mov     eax, DWORD PTR [rbp-12]
        pop     rbp
        ret

```

Указатель он более гибок чем ссылка, т.е например вы можете изменить константный указатель применив `const_cast`, тогда как к ссылке вы такого не сделаете, таким образом вы можете только изменить константность значения ссылки. Ну и ссылка это одноуровневая косвеность, а указатель это многоуровневая косвеность.

Для меня самыми основными приимуществами ссылки есть то что:

1. Ссылки нельзя инициализировать null, т.е. они всегда имееют коректную адресацию, особено это важно при написании функций
2. Ссылки могут расширять область жизни временных объектов(очень важно)
3. Ссылке нельзя поменять адресс(или другую ссылочную переменную), т.е. ссылка на протяжении своей жизни ссылаеться только на одну переменную.

Очень полезня цитата из C++ FAQ

```
Even though a reference is often implemented using an address in the underlying assembly language, please do not think of a reference as a funny looking pointer to an object. A reference is the object. It is not a pointer to the object, nor a copy of the object. It is the object.
```

Прочитав правда эту цитату или ответ, то что ссылка это объект, возникает вопрос как тогда получаються висячие ссылки????)))
```
#include <iostream>
#include <cassert>

int main(int argc, char const *argv[]) {
  int value1 = 40;
  // в этот момент происходит связь(расшаривание адрессов)
  int& ref1 = value1;
  assert(&ref1 == &value1);

  int value3 = 40;
  // в этом месте просто происходит изменения значения ссылки,
  // ref1 все еще указывает на value1
  ref1 = value3;
  assert(&ref1 != &value3);

  const int& cref = value1;
  
  // нельзя менять константное значение
  // cref = value3;

  // но можно так))
  const_cast<int &>(cref) = 90;

  assert(cref == 90);
  assert(value1 == 90);

  int array[3] {1, 2, 3};
  int (&ref_arr)[3] = array;
  ref_arr[1] = 90;
  assert(ref_arr[1] == array[1]);

  const int& rvref = 7;

  assert(rvref == 7);

  // такое не будет работать для указателя
  // const int* ptr = (int *)(&7);

  int *ptr = nullptr;

  // не вызовет падение программы
  int& ref_ptr = *ptr;

  // а так программа упадет
  ref_ptr = 2;
  return 0;
}

```

Как видно из примера выше, я вас немного обнанул можно сделать ссылку null))) как пример с ссылкой `ref_ptr`, но при попытке ее разыменовать мы получим падение программы.
#### Ссылки как часть интерфейса функции
Сами по себе ссылки никакого интереса не несут, а вот использования их в качестве интерфейса функции дает ряд приимуществ.
При передачи ссылок в качестве параметра функции ее не надо проверять на null(хотя есть случаи с null адресации). Если в качестве параметра написать константная ссылка то в качестве параметра можно передавать как lvalue так rvalue значения.
Ссылки также могут быть в качестве возращаемого значения с функции. Но если вы будете возращать локальную переменную по ссылке, и вас об этом уведомит компилятор, то в большинстве случаев вы плучите seg fault.
Также используя ссылку можна модифицировать указатели, т.е. поменять их адресс. При использовании указателей в качестве аргумента функции происходит копирования самой переменной указателя, т.е. если этой переменной присвоить другой адресс, то он никак не повлияет на оригинальные переменные, а если использовать ссылку то мы передаем переменную указатель по ссылки и можем менять ее содержимое, т.е. адресс. Этого можно также добиться используя двойной указатель.
```cpp
const int& cref_local() {
  int a = 90;
  return a;
}

void swap_ref_ptr(int* &ptr1, int* &ptr2) {
  int* ptr_tmp = ptr1;
  ptr1 = ptr2;
  ptr2 = ptr_tmp;
}

long summ(const int& a, const int& b) {
  return a + b;
}

.....
// в большинстве случаев получим seg fault
// assert(cref_local() == 90);

int value_ptr_sw1 = 40;
int value_ptr_sw2 = 80;
int *ptr_sw1 = &value_ptr_sw1;
int *ptr_sw2 = &value_ptr_sw2;
swap_ref_ptr(ptr_sw1, ptr_sw2);

assert(*ptr_sw1 == 80);
assert(*ptr_sw2 == 40);

assert(summ(value_ptr_sw1, value_ptr_sw2) == 120);
 
assert(summ(7, 2) == 9);

```

#### Отложенная инициализация(lazy initialization)
В некоторых случаях возможно возвращения локального объекта, с помощью так называеемого подхода lazy initialization. Суть в том что мы в теле функции объявляем статическую переменную, и она будет проинициализирована(создана) при первом заходе в функцию(блок) и при следующем входе уже не будет создаваться, а будет использоваться уже созданая переменная. И с функции можно возвращать ссылку на эту статическую переменную, так эта переменная выделяеться в сегменте данных а не на стеке.
```cpp
int& static_ref() {
  static int ref = 1;
  printf(__func__);
  printf("\nref == %d\n", ref);
  return ref;
}
....

++static_ref();
++static_ref();
++static_ref();
++static_ref();
int &ref_func = static_ref();
++ref_func;
static_ref();
```

### Стек и вызов функции
При вызове функции происходит довольно много интересного.
Программа на С++ использует основной концепт это stack работающих по принципу LIFO, т.е .при вызове фунции алгоритм приблизительно такой

1. Ложиться адресс возврата функции, т.е. адресс инструкции следующей за вызовом функции
2. Ложаться параметры при вызове функции
3. Ложаться все локальные переменные функции в стек
4. Адресс возвращаемого значения используеться по соглашонному регистру

Из описаного алгоритма вытекает то что мы можем получить переполнение стека, т.е. чем больше мы параметров передадим тем больше мы увеличиваем размер стека и чем больше мы объявляем локальных переменных тем больше растет стек. Если есть ограичения на стек то мы можем получить переполнения стека.

https://www.viva64.com/ru/t/0087/

### Соглашения о вызове
Это соглашение описывает как будут передаваться аргументы в стек, какие будут применяться ругистры, способ возврата результата с подпрограммы, кто ответсвенный за очистку стека.
В С/С++ применяеться в основном это `cdecl` и `thiscall`

https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B5

https://scc.ustc.edu.cn/zlsc/sugon/intel/compiler_c/main_cls/bldaps_cls/common/bldaps_calling_conv.htm

https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2017

### Рекурсия

Рекурсией называеться процесс в котором функция вызывает сама себя. В рекурсии важной особеностью есть условие остановки рекурсии. В основном смысл рекурсии это разбеение сложной задчи на мелкие. Т.е. примером это обход графа, или обход всех директорий устройства. Или частым примером есть числа фибоначи, их можно реализовать и через цикл, но намного эфективней будет через рекурсию.
Основной проблемой рекурсии это переполнения стека, если указано ограничение на стек, или не указано условия завершения рекурсии.
```cpp
#include <iostream>
 
unsigned long long fibNumber (unsigned number) {
  if (number < 2) {
    return number;
  }  
  return fibNumber(number - 1) + fibNumber(number - 2);
}
 
int main() {
  std::cout << fibNumber(6);
  return 0;
}
```

Еще один важный момент что если глубина вызова слишком большая то это приводит к замедлению выполнения програмы.


### Лямбда функции
Если не вдаваться в детали, то это неименнованные локальные функции, призваны решать небольшие быстрые задачи без необходимости создавать описываемую функцию в коде.
На самом деле лямбда это объект которые ведет себя как функция(т.е. это как перегрузка оператора вызова функции). Он имеет специальный тип `std::function` или правильно сказать может быть присвоеная объекту  `std::function`.
Впринципе лямбды содержат несколько строчек кода для использовании их в алгоритмах, в качестве обработчиков (callback), или отдельной точкой для работы потока и т.д. Пример алгоритма есть `std::sort`, где один из ее перегрузки принимает параметр указатель на функциию или другим словом компаратор.
Лямбды появились начиная с С++11 и продолжают еволюценировать, т.е. в начеле они были ограничены, но с каждым стандартом ограничения послабляються.
Синтаксис ее следующий
```
[ capture ] ( params ) specifiers exception attribute -> ret { body }

где

specifiers exception attribute -> ret - есть опциональной частью
```
Как видно из синтаксиса лямбды есть объязательный синтаксис.
Лямбды всегда начинаються с квадратных скобочек `[]`. Смысл их в том что они являються так называемым замыканием, т.е. захватывают параметры из вне в тело лямбды.
Всегда возникает вопрос а почему не передавать это в качестве параметров, то ответа тут два. Первый это то как реализована лямбда(перегрузка оператора вызова функции(функцтор), и нет возможности передавать дополнительные параметры), второй это то что можно передать в качесвте захвата весь скоп где вызываеться лямбда. Расмотрим комбинации захвата:

1. [] - указывает на то, что тело лямбда-выражения не имеет доступа к переменным во внешней области видимости
2. [&] - означает, что все переменные, на которые вы ссылаетесь, захвачены по ссылке. Но с захватом по ссылке надо быть очень осторожным так как можно получить висячую ссылку, если объект лямбды имеет дольше время жизни чем захвачена переменная по ссылке.
3. [=] - означает, что все переменные, на которые вы ссылаетесь, захвачены по значению. Т.е. в теле функции у нас будут копии объектов. Это есть предпотчительный вариант, если объект лямбды имеет время жизни больше чем захвачиваемые им переменные.
4. Вы можете захвачивать не весь внешний скоуп, а выборочные, т.е. конкретные переменные. [a, &b] где a захвачена по значению, а b захвачена по ссылке.
5. Начиная с С++14 появилась возможность захвата с инициализацией. `[x = 10]`, где `x` определяеться как новая переменная определенная в скопе лямбды. `[&r = x, y = x+1]` где `r` являеться ссылкой на `x`, а `y` являеться новой переменной.

Вторым важной частью лямбды есть круглые скобочки `()` в котрых могут как присутсвовать параметры так и отсутсвовать. Сюда будут передаваться аргументы при вызове лямбды. Все в принципе как в обычной функции но есть одно но, с приходом С++14 появились так называемые обобщенные лямбды. Т.е. если возможность объявления аргументов `auto` в функции это было как часть расширения компилятора, то такие параметры есть частью стандарта для лямбд. Также параметры по умолчанию были запрещены до C++14.
```cpp
[](auto a, auto b)
```
Тело функции, это та часть которая полностью идентична понятию тела обычной функции. Доступ к глобальным или статическим параметрам возможен без их захвата.

Дальше все идет опционально
specifiers сейчас их два вида:
1. mutable - это возможность изменять параметры в функции захваченые по значению, т.е. копии. Да-да звучит дичь, но это связано с тем что они захвачены как const.
2. constexpr - это возможность вызова лямбды в выражениях времени компиляции

ret - возращаемый тип. До С++14 в лямбде можно было автоматически вывести тип при одном только `return`, в С++14 это ограничение послабили, т.е. можно вывести тип из нескольких `return`. Но если компилятор не в состоянии вывести тип самостоятельно то для этого и применяеться этот спецификатор.

attribute - начиная с С++11 появилась возможность указания атрибута для функции. Например атрибут ` [[deprecated("because")]]` указывающий при вызове функции или функтора что он устарел и надо например использовать другую функцию.
```cpp

#include <iostream>
#include <algorithm>

// приходилось писать до с++14го

/*#include <functional>

std::function<long(int, int)> make_lambda() {
    return [](int a, int b = 20) -> long {
        return a + b;
    };
}*/

auto make_lambda() {
  return [](int a, int b = 20) {
           return a + b;
         };
}

auto make_lambda_several_ret() {
  return [](bool flag) -> long double {
           if (flag)
             return 10.25;
           else
             return 14;
         };
}

auto make_lambda_with_attr() {
  return [](int a, int b) [[deprecated("mult is deprecated")]] {
           return a * b;
         };
}

auto problem_with_ref(int& a) {
  int b = 90;
  return [&a, &b]() {
    std::cout << b << std::endl;
    ++a;
  };
}

auto generic_lambda() {
  return [](auto a, auto b) {
    return a + b;
  };
}

int main(int argc, char const *argv[]) {
  auto lambda = make_lambda();
  std::cout << lambda(1, 5) << std::endl;
  std::cout << lambda(10, 5) << std::endl;
  std::cout << lambda(1) << std::endl;

  std::cout << make_lambda_several_ret()(true) << std::endl;
  std::cout << make_lambda_several_ret()(false) << std::endl;

  int a = 40;
  // без mutable вы не сможете поменять значение copy_a
  [&new_a = a, copy_a = a](int param) mutable {
    new_a = param;
    ++copy_a;
  }(20);

  std::cout << a << std::endl;

  auto ref = problem_with_ref(a);
  ref();
  std::cout << a << std::endl;
  std::cout << generic_lambda()(10, 10) << std::endl;
  std::cout << generic_lambda()(10.40, 10) << std::endl;

  unsigned array[5] {5, 4, 3, 2, 1};
  std::sort(array, &array[5], [](unsigned a, unsigned b) {return a < b;});
  for (auto val : array) {
    std::cout << val << std::endl;
  }

  return 0;
}

```

### Inline функции
Суть inline фунций это часть оптимизации, т.е. вместо вызова функции и использования стека, компилятор просто встраивает в код тело функции в ее непосредственный вызов. Тут стоит сказать что inline это просто подсказка компилятору встраивать тело фунции, но это не значит что он так и поступит. В основном inline делают функции с несколькоми строчками кода, например если у вас будет больша фунция, то компилятор вряд ли сделает ее встраиваемой.
Синтаксис
```
inline bool is_odd(uint16_t number) {
  return number % 2;
}
``` 
### Перегрузка функций
Перегрузка функций в С++ это один из разновидностей полиморфизма в С++, называеться статическим. Т.е. компилятор на основе типов определенных во время компиляции определяет какую функцию необходимо вызвать.
Полиморфиз это одно из трех ключевых понятий ООП, сутьего в том что(простым словом) можно использовать одно и тоже имя для решение похожих но разных задач. Или как меня учили один интерфейс, но множество реализаций.
Простой пример это способ рисования фигур, т.е. метод один(интерфейс), а вот реализвция разная.
Более ралистичный пример это реализация фунции `abs` в стандартной библиотеке, т.е. в зависимости от типа выбираеться какая версия функции будет вызвана. Полимофизм не стоит путать с обобщенным программированием.
Перегрузка функций появилась только в С++, в С такого не было по причине того как компилятор конвертирует имена фунций. Т.е. в С коде имя функции на асемблерном уровне(в таблице имен) пишется так же само как в коде
Примеры
```cpp
int func(int a) {
  return a;
}

int main() {
  func(40);
	return 0;
}
```

Соберем ее как С программу, и применим к ней `objdump -t a.out`
```
.....
0000000000601020  w      .data	0000000000000000              data_start
0000000000601030 g       .data	0000000000000000              _edata
0000000000400574 g     F .fini	0000000000000000              _fini
0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000601020 g       .data	0000000000000000              __data_start
0000000000000000  w      *UND*	0000000000000000              __gmon_start__
0000000000601028 g     O .data	0000000000000000              .hidden __dso_handle
0000000000400580 g     O .rodata	0000000000000004              _IO_stdin_used
00000000004004d6 g     F .text	000000000000000c              func
0000000000400500 g     F .text	0000000000000065              __libc_csu_init
0000000000601038 g       .bss	0000000000000000              _end
00000000004003e0 g     F .text	000000000000002a              _start
0000000000601030 g       .bss	0000000000000000              __bss_start
00000000004004e2 g     F .text	0000000000000015              main
0000000000000000  w      *UND*	0000000000000000              _Jv_RegisterClasses
0000000000601030 g     O .data	0000000000000000              .hidden __TMC_END__
0000000000000000  w      *UND*	0000000000000000              _ITM_registerTMCloneTable
0000000000400390 g     F .init	0000000000000000              _init

```

Как видим функция `func` представлена в таблице символов, так как мы ее записали в коде.

А теперь соберем ту же программу только как С++ код, и посмотрим ее таблицу символов
```
.....
0000000000000000 l    df *ABS*	0000000000000000              
0000000000600e18 l       .init_array	0000000000000000              __init_array_end
0000000000600e28 l     O .dynamic	0000000000000000              _DYNAMIC
0000000000600e10 l       .init_array	0000000000000000              __init_array_start
0000000000400584 l       .eh_frame_hdr	0000000000000000              __GNU_EH_FRAME_HDR
0000000000601000 l     O .got.plt	0000000000000000              _GLOBAL_OFFSET_TABLE_
0000000000400570 g     F .text	0000000000000002              __libc_csu_fini
0000000000000000  w      *UND*	0000000000000000              _ITM_deregisterTMCloneTable
0000000000601020  w      .data	0000000000000000              data_start
0000000000601030 g       .data	0000000000000000              _edata
0000000000400574 g     F .fini	0000000000000000              _fini
0000000000000000       F *UND*	0000000000000000              __libc_start_main@@GLIBC_2.2.5
0000000000601020 g       .data	0000000000000000              __data_start
0000000000000000  w      *UND*	0000000000000000              __gmon_start__
0000000000601028 g     O .data	0000000000000000              .hidden __dso_handle
0000000000400580 g     O .rodata	0000000000000004              _IO_stdin_used
0000000000400500 g     F .text	0000000000000065              __libc_csu_init
0000000000601038 g       .bss	0000000000000000              _end
00000000004003e0 g     F .text	000000000000002a              _start
0000000000601030 g       .bss	0000000000000000              __bss_start
00000000004004e2 g     F .text	0000000000000015              main
0000000000000000  w      *UND*	0000000000000000              _Jv_RegisterClasses
00000000004004d6 g     F .text	000000000000000c              _Z4funci
0000000000601030 g     O .data	0000000000000000              .hidden __TMC_END__
0000000000000000  w      *UND*	0000000000000000              _ITM_registerTMCloneTable
0000000000400390 g     F .init	0000000000000000              _init

```

То как видим мы уже не сможем найти просто функцию `func`, а вместо нее есть функция `_Z4funci`. Что это такоеееее?) это назыветься то как С++ представляет имя функции добавляя к имени,дополнительную информацию типа, какой тип параметров, и сколько байт возращаемого значения.
Благодаря такому представлению имен функций и есть возможность применять перегрузку функций в С++, т.к. в таблице символов она будет иметь другое имя.
Примеры
```cpp
#include <cstdio>

void print(int a, int b) {
  printf("%s  a = %d, b = %d\n", __PRETTY_FUNCTION__, a, b); 
}

// не скомпилируеться т.к. тип передачи параметра по значению не играет роли const или не const
/*void print(const int a, int b) {
  printf("%s a = %d, b = %d", __func__, a, b); 
}*/

void print(float a, float b) {
  printf("%s a = %f, b = %f\n", __PRETTY_FUNCTION__, a, b); 
}

void print(double a, double b) {
  printf("%s a = %f, b = %f\n", __PRETTY_FUNCTION__, a, b); 
}

// для компилятора это будет неоднозначным такое определение
// т.е. перегрузка невозможна на основе возращаемого значения
/*long double print(double a, double b) {
  printf("%s a = %f, b = %f\n", __PRETTY_FUNCTION__, a, b); 
  return a + b;
}*/

void default_overload(int x) {
  printf("%s x = %d\n", __PRETTY_FUNCTION__, x); 
}

void default_overload(int x, int y = 40) {
  printf("%s x = %d, y = %d\n", __PRETTY_FUNCTION__, x, y); 
}

int main(int argc, char const *argv[]) {
  print(10, 20);
  print(10.90f, 20.90f);
  print(10.90, 20.90);
  /*
   не скомпилируеться, т.к. компилятор не найдет подходящую перегрузку для этой функции,
   и он будет предлагать возможные варианты, но если мы уберем перегрузку для вещественных чисел,
   то компилятор выберит только int используя неявное приведения типа 
  */
  // print(10.90, 20);
  /* 
    в данном случае компилятор выдст ошибку так не знает какую перегрузку вызвать
    т.е. возможен вызов как с одим параметром, так и с двумя (неоднозначность)
    перегрузка с параметром по умолчанию приводит к неоднозначности
  */
  // default_overload(40);
  default_overload(40, 90);
  return 0;
}

```

Выше приведена простая перегрузка на основе примитивных типов и передачи аргументов по значению. С приведеного примера можно сделать следующие выводы
1. Указание константности аргумента при передачи аргумента по значению, не играет роли, т.е. не участвует при перегрузке. Т.к. сточки зрения компилятора эти два аргумента одинаковы.
2. Возращаемое значение функции не участвует при перегрузки функции, в этом можно убедиться при просмотре таблици символов.
3. Также функции с параметром по умолчанию могут приводит к неоднозначности, т.е. они не участвуют в перегрузке функции.

Но правила немного меняються при использовании параметров как указателя, так и ссылок.
Пример
```cpp
#include <cstdio>

void print_ref(int& a) {
  printf("%s a = %d\n", __PRETTY_FUNCTION__, a);
  ++a;
}

void print_ref(const int& a) {
  printf("%s a = %d\n", __PRETTY_FUNCTION__, a);
}

void print_pointer(const int* a) {
  if (a != nullptr) {
    printf("%s a = %d\n", __PRETTY_FUNCTION__, *a);
  }
}

// будет ошибка компилятора, т.к. константность указателя не играет роли
/*
void print_pointer(const int* const a) {
  if (a != nullptr) {
    printf("%s a = %d\n", __PRETTY_FUNCTION__, *a);
  }
}*/

void print_pointer(int* a) {
  if (a != nullptr) {
    printf("%s a = %d\n", __PRETTY_FUNCTION__, *a);
    ++*a;
  }
}

void print_pointer(int a) {
  printf("%s a = %d\n", __PRETTY_FUNCTION__, a);
}

void swap_ptr(int* &ptr1, int* &ptr2) {
  printf("%s\n", __PRETTY_FUNCTION__);
  int *tmp_ptr = ptr1;
  ptr1 = ptr2;
  ptr2 = tmp_ptr;
}

void swap_ptr(int** ptr1, int** ptr2) {
  printf("%s\n", __PRETTY_FUNCTION__);
  int *tmp_ptr = *ptr1;
  *ptr1 = *ptr2;
  *ptr2 = tmp_ptr;
}

void swap_ptr(int* const * ptr1, int* const * ptr2) {
  printf("%s\n", __PRETTY_FUNCTION__);
}

int main(int argc, char const *argv[]) {
  int a = 1;
  const int b = 1;
  print_ref(a);
  print_ref(a);
  print_ref(2);
  print_pointer(&a);
  print_pointer(&b);
  print_pointer(0);
  // получим ошибку, т.к. есть неоднозначность какую функцию вызвать
  // print_pointer(nullptr);

  int swap_1 = 100;
  int swap_2 = 40;
  int *ptr1 = &swap_1;
  int *ptr2 = &swap_2;
  swap_ptr(ptr1, ptr2);
  printf("swap_1 = %d swap_2 = %d\n", *ptr1, *ptr2);
  swap_ptr(&ptr1, &ptr2);
  printf("swap_1 = %d swap_2 = %d\n", *ptr1, *ptr2);

  int * const * cptr1 = &ptr1;
  int * const * cptr2 = &ptr2;
  swap_ptr(cptr1, cptr2);
  return 0;
}
```

Как видно из примера выше ссылки и указатели есть разные типы при перегрузке. Также стоит быть осторожным с перегрузкой указателя и типом `int` если передавать в качестве аргумента 0, то будет выбран перегрузка c аргументом типа `int` вместо перегрузки с указателем.

### Удаляемые функции
В приведенном выше разделе мы расмотрели перегрузку функций, а как сделать так чтобы запретить неявное преобразование. Например мы хотим чтобы наша функция работала только с безнаковыми целыми числами, а со знаковыми и вещественными выдавать ошибку комиляции. Для этого есть два подхода:
1. Это объявить функцию с типом которым мы нехотим чтобы наша функция работала, но без тела функции. То при попытке мы получим ошибку типа что линковщик не может найти реализацию этой функции.
2. Это появление в С++ для этого ключевого слова `delete`, т.е. мы явно говорим читающему код что мы запрещаем вызов такой функции с таким параметром. Также это выдает более читаемую ошибку компиляции.
3. Также есть возможность использования расширения компилятора `#pragma GCC poison`, но еще раз это не переносимое решение.

Пример
```cpp
#include <cstdio>

void print(unsigned a) {
  printf("%s a = %d\n", a);
}

void print(int a) = delete;

int main(int argc, char const *argv[]) {
  print(10u);
  // ошибка компиляции использования удаленной функции void print(int)
  // print(10);
  return 0;
}

```

### Функци с переменным числом аргументов
В С++ так же как и в С можно писать функции с переменным числом аргументов. Идея этой функци строиться на понимании того какого типа параметры вы там будете использовать, т.е. используя знания того как на стеке храняться переменные и применяя это к указателю можно передвигатья по этомусписку параметров. Обязательным условием должно быть окончания итерации по стеку, если передать другое условие, то можно получить seg fault. В основном пишут применяя специальные макросы.
1.  va_list используетья до первого использования параметров, это есть объявление указателя
2.  va_start объявленый указатель связываеться с последним явным параметром
3. va_arg передвижение по стеку аргументов
4.  va_end это как удаление указателя.

```cpp
#include <cstdarg>
#include <iostream>

double average(unsigned num, ...) {
  va_list arguments;
  double sum = 0;

  va_start(arguments, num);
  for (unsigned x = 0; x < num; x++)
    sum += va_arg(arguments, double);
  va_end(arguments);

  return sum / num;
}

int main() {
  std::cout << average(3, 12.2, 22.3, 4.5) << std::endl;
  std::cout << average(5, 3.3, 2.2, 1.1, 5.5, 3.3) << std::endl;
}
```

### Массив как параметр функции
- Массивы в отличие от примитивных типов не передаются по значению
- Размерность массива при передачи как параметра в функцию игрнорируется
- Определение размера массива как в предедущем разделе с помощью sizeof дает не те ожидаимые результаты
- При передачи как параметра в функцию многомерного массива размерность первого уровня игнорируеться как и для одномерных массивов, а вот размер второго уровня необходимо указывать, иначе будет ошибка компиляции

```cpp
#include <stdio.h>

#define SIZE_ARRAY(array) sizeof((array)) / sizeof((array)[0])

void incorrect_print_array(int array[5]/*the same int array[]*/) {
  // результат будет не такой как ожидается(см. раздел с указателями)
  printf("array size in incorrect function %zu\n", SIZE_ARRAY(array));
  for (size_t i = 0; i < 5; ++i) {
    printf("%d ", array[i]);
  }
  printf("\n");
}

void correct_print_array(int array[], size_t length) {
  for (size_t i = 0; i < length; ++i) {
    printf("%d ", array[i]);
  }
  printf("\n");
}

void buble_sort(int (&array)[5]) {
  for (size_t i = 0; i < 5; ++i) {
    for (size_t j = 0; j < 5 -1; ++j) {
        if (array[j] > array[j + 1]) {
          int tmp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = tmp;
        }
    }
  }
}

// при передачи многомерного массива первый уровень игнорируеться компилятором как при работе с одномерным массивом
// а вот размер второго уровня обьязателен, если его указать или передать неверный размер то будет ошибка компиляции
void print_2D_array(int array[][2], size_t length_first_dim) {
  for (size_t i = 0; i < length_first_dim; ++i) {
    for (size_t j = 0; j < 2; ++j) {
      printf("%5d", array[i][j]);
    }
    printf("\n");
  }
}

int main(void) {
  int array[5] = {5, 4, 3, 2, 1};
  int array2[7] = {7, 6, 5, 4, 3, 2, 1};
  printf("array size is %zu\n", SIZE_ARRAY(array));
  buble_sort(array);
  // buble_sort(array2); compiler error initialization of reference of type ‘int (&)[5]’ from expression of type ‘int [7]’

  incorrect_print_array(array); // print 1 2 3 4 5
  // программа компилируеться без ошибок, так как по умолчанию размер массива игнорируеться
  incorrect_print_array(array2); // print 7 6 5 4 3

  correct_print_array(array2, SIZE_ARRAY(array2)); // print 7 6 5 4 3 2 1

  int array2D[][2] = {{1,2}, {3,4}, {5,6}};
  print_2D_array(array2D, SIZE_ARRAY(array2D));
  // int array2D_error[][3] = {{1,2,3}, {4,5,6}, {7,8,9}};
  // print_2D_array(array2D_error, SIZE_ARRAY(array2D_error)); // compilation error, несовместимость типов(размеров)
  return 0;
}
```
