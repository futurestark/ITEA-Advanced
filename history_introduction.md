# Немного истории
## Язык программирования
Язык программирования, также как и наш естетсвенный язык, являеться возможностью взаимодействия, т.е комуникации. В контексте программирования это возможность управлять нашим компьютером с помощью наборов инструкций. Другим словом язык программирования это набор инструкций спомощью которых программист взаимодействует с компьютером. Что имеется под словом управлять? Так как наш компьютер это просто машина которая что то исполняет если мы ее попросим ввиде инструкций, т.е. наш компьютер не несет логики, ему непонятен механизм печати на консоль сообщения или вывод графики на экран монитора, т.е мы ему даем набор данных и инструкции что с этими данными делать и он их выполнет. Для управления и применяеться язык программирования, под самими словом программирования и скрываеться смысл, т.е. мы пытаемся запрограмировать что то для выполнения каких либо целей. С помощью языков программирования мы можем что то печать на экран, отображать графику на экране, выполнять сложные вычисления, отправлять по сети данные между несколькоми копьютерами. Для достижения этих целей мы и используем язык программирования как механизм управления компьютером. В наше время языков программирования очень много, правда есть заметные лидеры, которые очень популярные в среде комъюнити и эфективны. И тот или другой язык программирования явлеться эфективным для разных целей, нельзя например взять и сказать что этот язык может решить все, он например может но сложность будет высока решение этой проблемы, когда есть другой язык который явно специализируеться на решение этой проблемы.
## Машинные языки
Машинный язык это набор инструкций(опкод) котрорые выполняються непосредственно процессором. Основным составляющими нашего компьютера есть память и центральный процессор, в оперативной памяти храняться программа и данные которыми оперирует наша программа, при этом программа состоит из простых машинных кодах которые передаються в центральный процессор на выполнения и процессор понимает и умеет выполнять эти простые команды(например взять значение с одной ячейки памяти в регистр сложит с другой и записать в третью и т.д.). Т.е. изначально машинные программировались в таких машинных кодах, т.е. набор чисел которые записывались в память и выполнялись ЦП.
Машинный язык являеться платформо зависимым, т.е. на разной архитектуре(компьютере) набор инструкций или адресация могут быть разной. Т.е. говорят что процессор А совметим с процессором В, если процессор А полностью понимает машинный код процессора В. Машинный код есть нативный код, т.е. код который являеться родным для данной архитектуры компьютера. Инструкция это набор битов, и как следствие написание програм являлось трудоемким и долгим занятием, и плохо понимаемым другими программистами смысла этой программы. Также одна програма написанная на одной архитектуре, необходимо было переписывать под другую архитектуру(разные инструкции)
https://ru.bmstu.wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4
И как следствие этого писать такие программы было очень не удобно. И начали придумывать т.к. называемые языки программирования.
## Низкоуровневые языки
Машинные коды, в принципе есть самый низкоровневый язык. Но как было сказано запоминать команды(инструкции) в двоичном формате очень сложно, поэтому начали придумывать мнемоники(или так называемые англоязычные абриавиатуры, или сокращения английских слов). Так появился язык асемблер, в котором вместо двоичных команд используюеться английские абривиатуры команд и вместо адресации памяти используеться именования адрессов. Т.е. язык ассемблер стал более человекоподобным и более проще в сопровождении другими програмистами. Стоит заметить что язык асемблер на каждом процессоре разный, из за разных моделей процессора со своим набором команд, т.е. он также платформено зависимый(возможно команды одни и теже, но вот могут например отличяться регистры и т.д.)
Язык ассемблер это не есть машинный код, он являеться прослойкой для написания машинных команд, т.е. в нем используються десятичные цифры, строки и т.д. Для перевода языка ассемблера на машинный код используеться специальная программа транслятор называемая Ассемблером(с этого и пошло назвние языка ассемблер). Сам по себе язык ассемблера являеться высокопроизводительным так как он более близок к апаратной платформе.
Язык ассемблера считаеться языком второго поколения, т.к. машинные коды есть первый язык программирования.
Иногда при отладке приложений можно видеть ассемблерный код, где справой стороны это ассемблерные команды, а с левой стороны транслируемые обьектные коды(опкоды), т.е. каждая инструкция на языке асемблер соответствует машинному коду.
Проблема ассемблера, как было сказано выше из за его разности на разных процессорах, то что не существует единого стандарта на язык низкого уровня.
Также есть еще низкоуровневый язык это CIL(Common Intermediate Language). Это высоуровневый ассемблер для виртуальной машины .NET.
https://xakep.ru/2017/09/11/asm-course-1/
## Высокоуровневые языки
Вследствии того что языки низкого уровня являються архитектурно зависимыми, их трудно было переносить с одной архитектуры на другую, или переписывать после обновления апаратуры, т.е. на другой платформе переносимую программу необходимо было переписывать(т.е. отсутствувала кросплатформеность). Вторая проблема низкоуровневых языков это то что для понимания их кода, нужны были продвинутые программисты со знанием архитектуры и т.д., что было трудно для других инженеров, математиков. Так начали появляться первые высокоуровневые языки программирования(первым был язык FORTRAN в котором инструкции были более приблеженными к математике), целью которых было скрыть всю сложность низкоуровневых языков.
Суть высокоуровневых языков это некая абстракция, т.е. логически описанных конструкций, написание которых на машинном коде было бы очень длинным и сложным для понимания. Из этого следует что целью также высоуровневых языков это быстрота написания програм, т.е. изоляция от архитектурных зависимостей, а больше концентрация над тем что должна делать программа. Другой стороной ВЯ являеться ее портирование на разные платформы. Перевод на машинные коды(на платформенную зависимость) ложилось на плечи других программ так называемых трансляторов. Из этого вытекает что ВЯ являються менее эфективны чем НЯ, из за дополнительных промежуточных трансляций.
Один опереатор написанный на языке высокого уровня, может транслируеться в множетсво машиных кодов(в эру оптимизации компиляторов может быть немного все по другом, т.е. множество написанных операторов ВЯ может сконвертиться в одну интсрукцию машиного кода)
Иногда когда необходима эфективность низкоуровневого языка. в высокуровневый язык стали добывлять подержку низкоуровневых вставок(для эфективной работы с паматью, или работы напрямую с оборудуванием).
Иногда бывает так что ВЯ являються также платформено зависимыми, например системные вызовы или другие взаимодействия с ОС которые мошут отличаться от системы к системе. чаще такое программирование называют системным программировнием. Другим видом программирования являющемся платформено зависимым есть embedded system.
## Трансляторы
С одной стороны у нас есть программа написанная на языке высокого уровня, с другой стороны наш компьютер или система понимает только машинные коды, и соответсвенно нам необходим некий механизм перевода программы на языке высокого уровня в машинные коды. Для этих целей существуют трансляторы, это программы предназначены для трансляции кода на языке высокого уровня в машинный код(который может быть все чем угодно, например язык ассемблер, объектные файлы и т.д.). Другими словами транслятор это преобразование программы с одного языка в программу на другом языке.
Существуют следующие виды трансляции:
- компиляция
- интерпритация
- динамическая компиляция
### Компиляция
Компилятор это программа которая имплиментирует язык программирования. Т.е. каждый язык программирования состоит из собственных компиляторов.
Простыми словами компилятор это трансляция языка высого уровня в язык низкого уровня(это может быть язык ассемблер, или обьектный файл, или машинные коды).
В компилятора есть понятие входа и есть понятие выхода, то что происходит в процессе компиляции и отличает его от других типов трансляции. На вход компилятор принимает исодный код нашей программы, а на выходе выдает exe файл или промежуточник(т.е. другую программу), который может быть разным в зависимости от типа компилятора(может быть как объктный файл, так и бай код и т.д.).
Немного истории первым компилятором был компилятор FORTRAN, его создаль (после создания интерпритатора) хотел чтобы исходный код сразу транслировался в машинный код (т.е. работал быстрей). Немного резюмируя то компилятор это некая программа у которой есть два интерфейса первый это язык программирования, а второй это различные флаги, размер стека и т.д.
### Интерпритация
Другим видом трансляции являеться интерпритация исходного кода. Интерпритация програмного кода выполняеться последовательно строчка за строчкой програмой называемой интерпритатором. Отличие интерпритатора от компилятора, как раз и состоит в том что происходит между входом и выходом, т.е как обрабатываеться язык программирования. Если компилятор преобразут весь исходный код в машинный код, то интерпритатор будет выполнять это всякий раз когда мы будем запускать нашу программу. Или другими словами это можно назвать так, интерпритатор это как онлайн, а компилятор это как офлайн. Минусом интерпритатора есть то что на исполняющей системе должна быть всегда программа интерпритатор, это время выполнения каждой инструкции. Плюсом есть то что любая интерпритирующая программа являеться переносимой. Из этого следует то что заранее скомпилированный код работает намного быстрее, но есть зависимость исполняемого кода от апаратной платформы. Это был пример простого интерпритатора, т.е. которые анализирует и сразу исполняет
Другой вид это так называемый интерпритаторы компилируемого типа(байт коды), это компиляция, но в отличии от привычной компиляции где код транслируеться сразу в машинный код, сдесь трансляция происходит в промежуточный код(байт код), который затем исполняеться(перобразуеться в машинный код) так называемой виртуальной машинной(интерпритатором). Плюсом такого подхода есть быстродействие выполняемой программы(за счет выноса анализа исходного кода в отдельный разовый проход, и минимизация его в интерпритаторе), и переносимость программы так как нет прямой зависимости от архитектуры исполняемой системы. Недостатком это требования к ресурсам. Бай код это некий компромис между компиляцией и интерпритацией.
Другим видом есть JIT компиоляция (just in time), т.е. компиляция во время выполнения. Т.е. подход раз скомпилирую и запускай где угодно был ресурсоемким, и был придуман механизм почему бы не компилипровать код перед выполнением, т.е. сохраняеться переносимость, но в тоже время происходит компиляция в нативный код, т.е виртуальная машина вызвает скомпилированный код вместо интерпритации его. JIT компиляция требует много процесорного времени и памяти, например некоторые инструкции кешируються для быстроты компиляции. На самом деле подход JIT применяеться для применение оптимизации(перестановка инструкций, удаление мертвого кода и т.д.) на этапе компиляции, как это притаманно обычной нативной компиляции
## Парадигма программирования
Этот термин применяеться как метод для решение некоторых проблем или решение некоторых задач. Другими словами это некий подход к решению задачи, или иногда называют стиль решение проблемы(набор идей и понятий). Стоит уточнить что в наше время множество языков поддерживают много парадигм программирования, но если например язык C не поддерживат обьектно ориентированную парадигму программирования это не значит что ее нельзя реализовать с помощью этого языка, вопрос в другом зачем?
Расмотрим следующие парадигмы программирования:
- модульный
- процедурный
- структурный
- объектно ориентированый
### Модульный
Разбиение задачи происходит независимыми модулями, или иногда называют блоками. К примеру есть група разработчиков которая работает над большей задачей, они разбивают эту задачу на небольшие модули которые могут разрабытываться независимомо друг от друга, а потом например некоторые модули связываються между собой для решения задчи.
Модуль это независимая единица трансляции, который может быть законченым фрагментом программы. Сам модуль внутри себя может содержать другую парадигму программирования. Удобство модуля заключаеться в том что вы можете модифицировать один из модулей не затрагиваю в целом систему. Иначе говоря модули реализую некий механизм инкапсуляции(принцип сокрытия данных). Модули также в некоторых языках программирования были заменены пакетами.
### Процедурный(функциональное программирование)
В процедурном программировании большая задача разбиваеться на более мелкие задачи процедуры или функции, и которые пропускают через себя набор данных. Т.е. можно сказать что у нас есть вызов функции которая принимает на вход какие то данные и возвращает результат т.е. необладает каким либо состоянием, или неизменяет состояные программы(ударение делалось на обработку данных с помощью алгорита). Типичным примером есть функция извлечения квадратного корня или функция возведения в степень.
### Структурное программирование
Структурное программирование это перввая реализация отказа от оператора goto, т.е. до СП все выглядело как спагети код. Основным понятием СП есть блок(последовательность), ветвление, циклы, подпрограммы(повторяющиеся фрагменты) и при этом разработка идет сверху вниз. Т.е. резумируя сказанное СП это такой подход который гарантирует более читаемый структуру программы, т.е. код становиться структурированным.
### Объектно ориентированное программирование
ООП более связано с нашей повседневной жизни, где все представлено классами и объектами этого класса(экземплрами). ООП также возникло как упрощенная модель написания кода, где ту или иную сущность можно представить ввиде класса и объекта. ООП позволяет хранить некое состояние на всей протижении жизни объекта. ООП она решает задачу структурного программирование,только на новом уровне. Т.е. ООП включает основные понятия:
- это абстракция данных обьекта
- это инкапсуляция
- это наследование
- это полиморфизм
- это класс
- это объект
Например есть класс FORD Mondeo, а модель FORD Mondeo это конкретный экземпляр автомобиля с неким состояние, при этом это состояние никак не пересекаеться с состояние других обьектов этого же класса, они только могут обменяться этим состоянием.
### Обобщенное программирование
Идея ОП заключаеться в том чтобы обобщить алгоритмы и структуры данных(списки, очередь и т.д.) в контексте разных типов, которые удовлетворяют тем или иным требованиям обобщеного алгоритма или структуры данных. Например функция обмена переменными(swap), заключаеться в том что тип обмениваемых переменных должен содержать оператор присваивания.
Простыми словами ОП это написание структур данных и алгоритмов которые могут работать с разными типами данных без изменения их описания(содержимого). Язык С++ содержит больщую библиотеку обобщенных данных и обобщенных алгоритмов раюоты над ними, которая называеться STL(Standard Template Library).
## История С++
 ![](cpp_evolution.png)

История языка С++ начинаеться с 1980х годов, который был придуман Бьёрн Страуструпом. Он пытался решить ряд задач, на то время существующими языками программирования, но каждый из них имел те или иные ограничения. Поэтому вспомнив работу над своей дисертацией, он начал работу над уже существующим популярным языком C(Деннисом Ритчи, являющимся многофункциональным и переносимым), который являлся базовым языком системы Unix. Страуструп добавил в язык С работу с классами, откуда и пошло первое название С с класамми. Для этого была им написана утилита сfront - которая транслировала С с классами в язык С(мы видим еще один подход трансляции, а именно трансляция языка высокого уровня в язык высокого уровня).
Но не ожидая того язык С++ начал набирать большую популярность среди общества, и в 1985 году была его первая комерчиская реализация. В него были включены виртуальные функции, константы, ссылки, более строгий контроль типов, перегрузка операторов. В связи с этим он был перейменован в язык С++, т.е. язык С с улучшением. До 1998 г. небыло единого стандарта по этому языку, и сам Страуструп поддерживал язык самостоятельно(документация и т.д.), но в 1998 был сформирован комитет задачей которого было формироваия международного стандарта и в этом году был принят официальный стандарт. А в 2003 был принят новый стандарт, с незначительными изменениями.
https://en.cppreference.com/w/cpp/compiler_support
Как было сказано язык С являеться родителем языка С++, из этого следует что почти все программы на языке С есть программы языка С++(т.е. компилируються), но обратное не верно.
TR( Library Technical Report 1) не являеться основной частью стандарта, это есть некоторотое расширение стандартной библиотеки(регулярные выражение, генераторы случайных чисел и т.д.). До С++11 было приблизительно опубликовано 3 TR которые очень сильно повлияли на стандарт С++11